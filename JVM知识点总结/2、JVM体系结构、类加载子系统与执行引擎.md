# JVM体系结构&类加载子系统

# 1、JVM-跨语言的平台

## 1.1 认识

<img src="https://npm.elemecdn.com/youthlql@1.0.8/JVM/chapter_001/0010.png">



1. 随着Java7的正式发布，Java虚拟机的设计者们通过JSR-292规范基本实现在Java虚拟机平台上运行非Java语言编写的程序。
2. **Java虚拟机根本不关心运行在其内部的程序到底是使用何种编程语言编写的，它只关心“字节码”文件。也就是说Java虚拟机拥有语言无关性，**并不会单纯地与Java语言“终身绑定”，只要其他编程语言的编译结果满足并包含Java虚拟机的内部指令集、符号表以及其他的辅助信息，它就是一个有效的字节码文件，就能够被虚拟机所识别并装载运行。

- Java不是最强大的语言，但是JVM是最强大的虚拟机

1. 我们平时说的java字节码，指的是用java语言编译成的字节码。准确的说任何能在jvm平台上执行的字节码格式都是一样的。所以应该统称为：jvm字节码。
2. 不同的编译器，可以编译出相同的字节码文件，字节码文件也可以在不同的JVM上运行。
3. Java虚拟机与Java语言并没有必然的联系，它只与特定的二进制文件格式——Class文件格式所关联，Class文件中包含了Java虚拟机指令集（或者称为字节码、Bytecodes）和符号表，还有一些其他辅助信息。



## 1.2 多语言混合编程

1. Java平台上的多语言混合编程正成为主流，通过特定领域的语言去解决特定领域的问题是当前软件开发应对日趋复杂的项目需求的一个方向。
2. 试想一下，在一个项目之中，并行处理用Clojure语言编写，展示层使用JRuby/Rails，中间层则是Java，每个应用层都将使用不同的编程语言来完成，而且，接口对每一层的开发者都是透明的，各种语言之间的交互不存在任何困难，就像使用自己语言的原生API一样方便，因为它们最终都运行在一个虚拟机之上。
3. 对这些运行于Java虚拟机之上、Java之外的语言，来自系统级的、底层的支持正在迅速增强，以JSR-292为核心的一系列项目和功能改进（如DaVinci Machine项目、Nashorn引擎、InvokeDynamic指令、java.lang.invoke包等），推动Java虚拟机从“Java语言的虚拟机”向 “多语言虚拟机”的方向发展。



## 1.3 JVM的整体结构

1. HotSpot VM是目前市面上高性能虚拟机的代表作之一。
2. 它采用解释器与即时编译器并存的架构。
3. 在今天，Java程序的运行性能早已脱胎换骨，已经达到了可以和C/C++程序一较高下的地步。

> 下面是JVM的整体流程图，在2.1中也有介绍

第一种形式：

<img src="https://npm.elemecdn.com/youthlql@1.0.8/JVM/chapter_001/0015.png">

第二种形式：

<img src="https://npm.elemecdn.com/youthlql@1.0.8/JVM/chapter_002/0003.jpg">

整体结构图：

<img src="https://npm.elemecdn.com/youthlql@1.0.8/JVM/chapter_001/0014.png">



## 1.4 Java代码执行流程

凡是能生成被Java虚拟机所能解释、运行的字节码文件，那么理论上我们就可以自己设计一套语言了

<img src="https://npm.elemecdn.com/youthlql@1.0.8/JVM/chapter_001/0016.png">



## 1.5 JVM的架构模型

Java编译器输入的指令流基本上是一种**基于栈的指令集架构**，另外一种指令集架构则是**基于寄存器的指令集架构**。具体来说：这两种架构之间的区别：

### 基于栈的指令集架构

基于栈式架构的特点：

1. 设计和实现更简单，适用于资源受限的系统；
2. 避开了寄存器的分配难题：使用零地址指令方式分配
3. 指令流中的指令大部分是零地址指令，其执行过程依赖于操作栈。指令集更小，编译器容易实现
4. 不需要硬件支持，可移植性更好，更好实现跨平台

### 基于寄存器的指令级架构

基于寄存器架构的特点：

1. 典型的应用是x86的二进制指令集：比如传统的PC以及Android的Davlik虚拟机。
2. 指令集架构则完全依赖硬件，与硬件的耦合度高，可移植性差
3. 性能优秀和执行更高效
4. 花费更少的指令去完成一项操作
5. 在大部分情况下，基于寄存器架构的指令集往往都以一地址指令、二地址指令和三地址指令为主，而基于栈式架构的指令集却是以零地址指令为主

### JVM架构总结

1. **由于跨平台性的设计，Java的指令都是根据栈来设计的**。不同平台CPU架构不同，所以不能设计为基于寄存器的。栈的优点：跨平台，指令集小，编译器容易实现，缺点是性能比寄存器差一些。
2. 时至今日，尽管嵌入式平台已经不是Java程序的主流运行平台了（准确来说应该是HotSpot VM的宿主环境已经不局限于嵌入式平台了），那么为什么不将架构更换为基于寄存器的架构呢？

- 因为基于栈的架构跨平台性好、指令集小，虽然相对于基于寄存器的架构来说，基于栈的架构编译得到的指令更多，执行性能也不如基于寄存器的架构好，但考虑到其跨平台性与移植性，我们还是选用栈的架构





# ===

# 2、类加载子系统

# 2.1 JVM内存结构概述

> 1.3中也有相关的介绍，可以结合起来看

### 2.1.1 简图

<img src="https://npm.elemecdn.com/youthlql@1.0.8/JVM/chapter_002/0001.png">

### 2.1.2 详细图

英文版

<img src="https://npm.elemecdn.com/youthlql@1.0.8/JVM/chapter_002/0002.jpg">

中文版

<img src="https://npm.elemecdn.com/youthlql@1.0.8/JVM/chapter_002/0003.jpg">

LV OS DL RA 指的是 本地变量表（Local Variables）、操作数栈（Operand Stack）、动态链接（Dynamic Link）、返回地址（Return Address），其实还有一些别的，后面会介绍到。

注意：方法区只有HotSpot虚拟机有，J9，JRockit都没有



## 2.2 类加载子系统的作用与类加载器ClassLoader

### 2.2.1 类加载子系统

1. 类加载器子系统负责从文件系统或者网络中加载Class文件，class文件在文件开头有特定的文件标识。
2. **ClassLoader**只负责class文件的加载，至于它是否可以运行，则由Execution Engine决定。
3. **加载的类信息存放于一块称为方法区的内存空间**。除了类的信息外，方法区中还会存放运行时常量池信息，可能还包括字符串字面量和数字常量（这部分常量信息是Class文件中常量池部分的内存映射）

<img src="https://npm.elemecdn.com/youthlql@1.0.8/JVM/chapter_002/0004.png">

### 2.2.2 ClassLoader

1. class file（在下图中就是Car.class文件）存在于本地硬盘上，可以理解为设计师画在纸上的模板，而最终这个模板在执行的时候是要加载到JVM当中来根据这个文件实例化出n个一模一样的实例。
2. class file加载到JVM中，被称为DNA元数据模板（在下图中就是内存中的Car Class），放在方法区。
3. 在.class文件–>JVM–>最终成为元数据模板，此过程就要一个**运输工具**（类装载器Class Loader），扮演一个快递员的角色。

<img src="https://npm.elemecdn.com/youthlql@1.0.8/JVM/chapter_002/0005.png">



## 2.3 类加载过程

### 2.3.0 类加载过程概述

类加载主要有三个阶段（五个过程），分别为：

- 加载阶段
- 链接阶段
  - 验证（Vertify）
  - 准备（Prepare）
  - 解析（Resolve）
- 初始化阶段

这只是抽象的过程，事实上JVM加载时不一定完全按照这个过程进行加载，具体根据JVM的实现。

<img src="https://npm.elemecdn.com/youthlql@1.0.8/JVM/chapter_002/0006.png">

完整的流程图如下所示：

<img src="https://npm.elemecdn.com/youthlql@1.0.8/JVM/chapter_002/0007.png">



### 2.3.1 加载阶段

**加载：**

1. 通过一个类的全限定名获取定义此类的二进制字节流
2. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
3. **在内存中生成一个代表这个类的java.lang.Class对象**，作为方法区这个类的各种数据的访问入口



### 2.3.2 链接阶段

链接分为三个子阶段：验证 -> 准备 -> 解析



#### 验证(Verify)

1. 目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身安全
2. 主要包括四种验证，文件格式验证，元数据验证，字节码验证，符号引用验证。



#### 准备(Prepare)

1. 为类变量（static变量）分配内存并且设置该类变量的默认初始值，即零值
2. 这里不包含用final修饰的static，因为final在编译的时候就会分配好了默认值，准备阶段会显式初始化
3. 注意：这里不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量是会随着对象一起分配到Java堆中

**举例**

代码：变量a在准备阶段会赋初始值，但不是1，而是0，在初始化阶段会被赋值为 1

```java
public class HelloApp {
    private static int a = 1;//prepare：a = 0 ---> initial : a = 1


    public static void main(String[] args) {
        System.out.println(a);
    }
}
```

> 即准备阶段会为类的静态变量分配内存以及初始值。
>
> - 基本数据类型的初始值
>
> | 数据类型  | 默认初始值           | 说明                                                        |
> | --------- | -------------------- | ----------------------------------------------------------- |
> | `byte`    | 0                    | 8位有符号整数                                               |
> | `short`   | 0                    | 16位有符号整数                                              |
> | `int`     | 0                    | 32位有符号整数                                              |
> | `long`    | 0L                   | 64位有符号整数                                              |
> | `float`   | 0.0f                 | 32位单精度浮点数                                            |
> | `double`  | 0.0d                 | 64位双精度浮点数                                            |
> | `char`    | '\u0000'（null字符） | 16位字符，初始值是Unicode的空字符                           |
> | `boolean` | `false`              | 逻辑类型，底层以`0`表示`false`，`1`表示`true`（用户不可见） |
>
> - 引用类型的初始值
>
> | 数据类型     | 默认初始值 |
> | ------------ | ---------- |
> | 所有引用类型 | `null`     |



#### 解析(Resolve)



1. **将常量池内的符号引用转换为直接引用的过程**
2. 事实上，解析操作往往会伴随着JVM在执行完初始化之后再执行
3. 符号引用就是一组符号来描述所引用的目标。符号引用的字面量形式明确定义在《java虚拟机规范》的class文件格式中。直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄
4. 解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等。对应常量池中的CONSTANT Class info、CONSTANT Fieldref info、CONSTANT Methodref info等

**符号引用**

- 反编译 class 文件后可以查看符号引用，下面带# 的就是符号引用

<img src="https://npm.elemecdn.com/youthlql@1.0.8/JVM/chapter_002/0023.png"/>



### 2.3.3 初始化阶段

#### 2.3.3.1 类的初始化时机

Java类只有主动调用的时候才会进行初始化，具体情况有：

1. 创建类的实例
2. 访问某个类或接口的静态变量，或者对该静态变量赋值
3. 调用类的静态方法
4. 反射（比如：Class.forName(“com.atguigu.Test”)）
5. 初始化一个类的子类
6. Java虚拟机启动时被标明为启动类的类
7. JDK7开始提供的动态语言支持：java.lang.invoke.MethodHandle实例的解析结果REF_getStatic、REF putStatic、REF_invokeStatic句柄对应的类没有初始化，则初始化

除了以上七种情况，其他使用Java类的方式都被看作是对类的被动使用，都不会导致类的初始化，即不会执行初始化阶段（不会调用 clinit() 方法和 init() 方法）



**clinit()**

1. 初始化阶段就是执行类构造器方法`<clinit>()`的过程

2. 此方法不需定义，是javac编译器自动收集类中的所有**类变量**的赋值动作和静态代码块中的语句合并而来。也就是说，当我们代码中包含static变量的时候，就会有clinit方法

3. `<clinit>()`方法中的指令按语句在源文件中出现的顺序执行

4. `<clinit>()`不同于类的构造器。（关联：构造器是虚拟机视角下的`<init>()`）

   > 也就是说clinit和init是两个函数，clinit在初始化阶段调用。用类进行举例
   >
   > ```java
   > public class Test {
   >     public static int num = 1; // 静态变量
   > 
   >     // 构造函数
   >     Test() {
   >         num = 2; // 改变静态变量的值
   >     }
   > 
   >     public static void main(String[] args) {
   >         System.out.println("Before creating objects: " + Test.num); // 输出 1
   >         Test t1 = new Test();
   >         System.out.println("After creating first object: " + Test.num); // 输出 2
   >         Test t2 = new Test();
   >         System.out.println("After creating second object: " + Test.num); // 输出 2
   >     }
   > }
   > ```
   >
   > ```shell
   > Before creating objects: 1
   > After creating first object: 2
   > After creating second object: 2
   > ```
   >
   > - 准备阶段给num分配内存，赋值为默认值0。
   > - 初始化阶段调用clinit，给num进行初始化，赋值为1。此时类构造完成，进入方法区（永久代/元空间）成为类的元数据。
   > - 当类的对象被创建时，调用init调用，按照类的构造函数对类进行构造，此时将类的静态变量num赋值为2。

5. 若该类具有父类，JVM会保证子类的`<clinit>()`执行前，父类的`<clinit>()`已经执行完毕

6. 虚拟机必须保证一个类的`<clinit>()`方法在多线程下被同步加锁

当我们代码中包含static变量的时候，就会有clinit方法；没有静态变量就不会生成clinit方法。



## 2.4 类加载器的分类

### 2.4.1 概述

1. JVM严格来讲支持两种类型的类加载器 。分别为**引导类加载器（Bootstrap ClassLoader）**和**自定义类加载器（User-Defined ClassLoader）**

2. 从概念上来讲，自定义类加载器一般指的是程序中由开发人员自定义的一类类加载器，但是Java虚拟机规范却没有这么定义，而是**将所有派生于抽象类ClassLoader的类加载器都划分为自定义类加载器**

   > 即我们平常对类加载器的分类与规范定义有差别。
   >
   > - 我们一般认为JVM的”启动类加载器“、”扩展类加载器“、”系统类加载器“为JVM自带的加载器，而我们的加载器为用户自定义加载器。
   > - JVM规范规定“启动类加载器（Bootstrap ClassLoader）”为引导类加载器，其他所有的加载器都是继承ClassLoader的，都属于自定义类加载器。启动类加载器的代码是写死进JVM的，而且不是单纯通过Java实现的。
   >
   > 注意区分**父类加载器**和**继承**两个概念，父类加载器是启动过程上的逻辑关系，而继承是实实在在通过extends关键字实现的。

3. 无论类加载器的类型如何划分，在程序中我们最常见的类加载器始终只有3个，如下所示

<img src="https://npm.elemecdn.com/youthlql@1.0.8/JVM/chapter_002/0014.png" style="zoom:75%;">

- **因为引导类加载器右 C/C++ 语言，我们获取不到**
- **系统类加载器是全局唯一的**



扩展类加载器和系统类加载器各自的继承关系

**ExtClassLoader**

<img src="https://npm.elemecdn.com/youthlql@1.0.8/JVM/chapter_002/0015.png" style="zoom:40%;">

**AppClassLoader**

<img src="https://npm.elemecdn.com/youthlql@1.0.8/JVM/chapter_002/0016.png" style="zoom:40%;">



### 2.4.2 虚拟机自带的加载器

#### 2.4.2.1 启动类加载器

> **启动类加载器（引导类加载器，Bootstrap ClassLoader）**

1. 这个类加载使用C/C++语言实现的，嵌套在JVM内部
2. 它用来加载Java的核心库（JAVA_HOME/jre/lib/rt.jar、resources.jar或sun.boot.class.path路径下的内容），用于提供JVM自身需要的类
3. 并不继承自java.lang.ClassLoader，没有父加载器
4. 加载扩展类和应用程序类加载器，并作为他们的父类加载器
5. 出于安全考虑，Bootstrap启动类加载器只加载包名为java、javax、sun等开头的类
6. 启动类加载器不允许用户自己创建java等包并编写代码和加载（比如在src下创建java.lang）



#### 2.4.2.2 扩展类加载器

> **扩展类加载器（Extension ClassLoader）**

1. Java语言编写，由sun.misc.Launcher$ExtClassLoader实现
2. 派生于ClassLoader类
3. 父类加载器为启动类加载器
4. 从java.ext.dirs系统属性所指定的目录中加载类库，或从JDK的安装目录的jre/lib/ext子目录（扩展目录）下加载类库。如果用户创建的JAR放在此目录下，也会自动由扩展类加载器加载



#### 2.4.2.3系统类加载器

> **应用程序类加载器（也称为系统类加载器，AppClassLoader）**

1. Java语言编写，由sun.misc.LaunchersAppClassLoader实现
2. 派生于ClassLoader类
3. 父类加载器为扩展类加载器
4. 它负责加载环境变量classpath或系统属性java.class.path指定路径下的类库
5. 该类加载是程序中默认的类加载器，一般来说，Java应用的类都是由它来完成加载
6. 通过classLoader.getSystemclassLoader()方法可以获取到该类加载器





### 2.4.3 用户自定义类加载器

#### 2.4.3.1 什么时候需要自定义类加载器？

1. 隔离加载类（比如说我假设现在Spring框架，和RocketMQ有包名路径完全一样的类，类名也一样，这个时候类就冲突了。不过一般的主流框架和中间件都会自定义类加载器，实现不同的框架，中间价之间是隔离的）
2. 修改类加载的方式
3. 扩展加载源（还可以考虑从数据库中加载类，路由器等等不同的地方）
4. 防止源码泄漏（对字节码文件进行解密，自己用的时候通过自定义类加载器来对其进行解密）
5. 实现类的及时GC（类的GC条件很严格，其中有一条就是加载该类的类加载器已经被回收）

#### 如何自定义类加载器？

1. 通过继承抽象类java.lang.ClassLoader类的方式，实现自己的类加载器
2. 在JDK1.2之前，继承ClassLoader类并重写loadClass()方法，从而实现自定义的类加载类；在JDK1.2之后可以并建议把自定义的类加载逻辑写在findclass()方法中
3. 在编写自定义类加载器时，如果没有太过于复杂的需求，可以直接继承URIClassLoader类，这样就可以避免自己去编写findclass()方法及其获取字节码流的方式，使自定义类加载器编写更加简洁。



### 2.4.4 关于ClassLoader

> **ClassLoader 类介绍**

ClassLoader类，它是一个抽象类，其后所有的类加载器都继承自ClassLoader（不包括启动类加载器）

<img src="https://npm.elemecdn.com/youthlql@1.0.8/JVM/chapter_002/0017.png">



#### 获取ClassLoader途径

<img src="https://npm.elemecdn.com/youthlql@1.0.8/JVM/chapter_002/0019.png">



## 2.5 双亲委派机制

### 2.5.1 双亲委派机制原理

Java虚拟机对class文件采用的是**按需加载**的方式，当需要使用类时才将它的class文件加载到内存生成class对象。

加载某个类的class文件时，Java虚拟机采用的是双亲委派模式，即把请求交由父类处理，它是一种任务委派模式

1. 如果一个类加载器收到了类加载请求，他会先把这个请求委托给父类的加载器去执行；
2. 如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器；
3. 如果父类加载器可以完成类加载任务，就成功返回，如果不能，交给下一级子加载器去加载；
4. 如果将加载任务分配至系统类加载器也无法加载此类（如果有自定义加载器就是到自定义加载器），则抛出异常

<img src="https://npm.elemecdn.com/youthlql@1.0.8/JVM/chapter_002/0020.png">



### 2.5.2 双亲委派机制优势

1. 避免类的重复加载
2. 保护程序安全，防止核心API被随意篡改
   - **自定义类：自定义String类不会被加载**，加载出来的是String类，在自定义的String类里面写main并调用会报错，因为Java实现的String类里面并没有main可供调用。
   - **自定义类：java.lang.ShkStart**（报错：阻止创建 java.lang开头的类）



## 2.6 沙箱安全机制

1. 自定义String类时：在加载自定义String类的时候会率先使用引导类加载器加载，而引导类加载器在加载的过程中会先加载jdk自带的文件（rt.jar包中java.lang.String.class），报错信息说没有main方法，就是因为加载的是rt.jar包中的String类。
2. 这样可以保证对java核心源代码的保护，这就是沙箱安全机制。



## 2.7 其他

### 2.7.1 如何判断两个class对象是否相同？

在JVM中表示两个class对象是否为同一个类存在两个必要条件：

1. 类的完整类名必须一致，包括包名
2. **加载这个类的ClassLoader（指ClassLoader实例对象）必须相同**

> 换句话说，在JVM中，即使这两个类对象（class对象）来源同一个Class文件，被同一个虚拟机所加载，但只要加载它们的ClassLoader实例对象不同，那么这两个类对象也是不相等的



### 2.7.2 对类加载器的引用

1. JVM必须知道一个类型是由启动加载器加载的还是由用户类加载器加载的
2. **如果一个类型是由用户类加载器加载的，那么JVM会将这个类加载器的一个引用作为类型信息的一部分保存在方法区中**
3. 当解析一个类型到另一个类型的引用的时候，JVM需要保证这两个类型的类加载器是相同的





# ===

# 3、执行引擎

# 3.1 执行引擎概述

执行引擎（Execution Engine）的任务就是**将字节码指令解释/编译为对应平台上的本地机器指令才可以**。简单来说，JVM中的执行引擎充当了将高级语言翻译为机器语言的译者。

<img src="https://npm.elemecdn.com/youthlql@1.0.8/JVM/chapter_008/0002.png">

1、前端编译：从Java程序员-字节码文件的这个过程叫前端编译

2、执行引擎这里有两种行为：一种是解释执行，一种是编译执行（这里的是后端编译）。



## 3.2 Java代码编译和执行过程

### 3.2.1 解释执行和即时编译

1. 前面橙色部分是编译生成生成字节码文件的过程（javac编译器来完成，也就是前端编译器），和JVM没有关系。
2. 后面绿色（解释执行）和蓝色（即时编译）才是JVM需要考虑的过程

<img src="https://npm.elemecdn.com/youthlql@1.0.8/JVM/chapter_008/0004.png">

3. javac编译器（前端编译器）流程图如下所示：

   <img src="https://npm.elemecdn.com/youthlql@1.0.8/JVM/chapter_008/0005.png">

4. Java字节码的执行是由JVM执行引擎来完成，流程图如下所示

   <img src="https://npm.elemecdn.com/youthlql@1.0.8/JVM/chapter_008/0006.png">

   



### 3.2.2 什么是解释器？什么是JIT编译器？

1. 解释器：当Java虚拟机启动时会根据预定义的规范对字节码采用**逐行**解释的方式**执行**，将每条字节码文件中的内容“翻译”为对应平台的本地机器指令执行。
2. JIT（Just In Time Compiler）编译器：就是虚拟机将源代码**一次性直接**编译成和本地机器平台相关的机器语言，**但并不是马上执行**。



**为什么Java是半编译半解释型语言？**

1. JDK1.0时代，将Java语言定位为“解释执行”还是比较准确的。再后来，Java也发展出可以直接生成本地代码的编译器。
2. 现在JVM在执行Java代码的时候，通常都会将解释执行与编译执行二者结合起来进行。
3. JIT编译器将字节码翻译成本地代码后，就可以做一个缓存操作，存储在方法区的JIT 代码缓存中（执行效率更高了），并且在翻译成本地代码的过程中可以做优化。



**用图总结一下**

<img src="https://npm.elemecdn.com/youthlql@1.0.8/JVM/chapter_008/0007.png">



## 3.3 解释器

### 3.3.1 解释器的分类

在Java的发展历史里，一共有两套解释执行器，即古老的**字节码解释器**、现在普遍使用的**模板解释器**。

- 字节码解释器在执行时通过纯软件代码模拟字节码的执行，效率非常低下。
- 而模板解释器将每一条字节码和一个模板函数相关联，模板函数中直接产生这条字节码执行时的机器码，从而很大程度上提高了解释器的性能。



### 3.3.2 解释器的现状

为了解决解释执行速度慢的问题，JVM平台支持一种叫作即时编译的技术（JIT）。即时编译的目的是避免函数被解释执行，而是将整个函数体编译成为机器码，每次函数执行时，只执行编译后的机器码即可，这种方式可以使执行效率大幅度提升。



## 3.4 JIT编译器

### 3.4.1 Java 代码执行的分类

1. 第一种是将源代码编译成字节码文件，然后在运行时通过解释器将字节码文件转为机器码执行
2. 第二种是编译执行（直接编译成机器码）。现代虚拟机为了提高执行效率，会使用即时编译技术（JIT，Just In Time）将方法编译成机器码后再执行



### 3.4.2 HotSpot代码执行架构

1. HotSpot VM**采用解释器与即时编译器并存的架构**，解释器和即时编译器相互协作尽力去选择最合适的方式来权衡编译本地代码的时间和直接解释执行代码的时间。
2. 在今天，Java程序的运行性能早已脱胎换骨，已经达到了可以和C/C++ 程序一较高下的地步。



### 3.4.3 为啥我们还需要解释器呢？

**首先明确两点：**

1. 当程序启动后，解释器**响应速度快**，省去编译的时间，立即执行。
2. 编译器要想发挥作用，把代码编译成本地代码，**需要一定的执行时间**，但编译为本地代码后，执行效率高。

**所以：**

1. 尽管JRockit VM只采用即时编译器，程序的执行性能非常高效，但程序在启动时必然需要花费更长的时间来进行编译。对于服务端应用来说，启动时间并非是关注重点，但对于那些看中启动时间的应用场景而言，或许就需要采用解释器与即时编译器并存的架构来换取一个平衡点。
2. 在此模式下，在Java虚拟器启动时，解释器可以首先发挥作用，而不必等待即时编译器全部编译完成后再执行，这样可以省去许多不必要的编译时间。随着时间的推移，编译器发挥作用，把越来越多的代码编译成本地代码，获得更高的执行效率。
3. 同时，解释执行在编译器进行激进优化不成立的时候，作为编译器的“逃生门”（后备方案）。



### 3.4.4 案例

- 当虚拟机启动的时候，解释器可以首先发挥作用，而不必等待即时编译器全部编译完成再执行，这样可以省去许多不必要的编译时间。
- 随着程序运行时间的推移，即时编译器逐渐发挥作用，根据热点探测功能，将有价值的字节码编译为本地机器指令，以换取更高的程序执行效率。

**注意：**

1. 注意解释执行与编译执行在线上环境微妙的辩证关系。**机器在热机状态（已经运行了一段时间叫热机状态）可以承受的负载要大于冷机状态（刚启动的时候叫冷机状态）**。如果以热机状态时的流量进行切流，可能使处于冷机状态的服务器因无法承载流量而假死。
2. 在生产环境发布过程中，以分批的方式进行发布，根据机器数量划分成多个批次，每个批次的机器数至多占到整个集群的1/8。曾经有这样的故障案例：某程序员在发布平台进行分批发布，在输入发布总批数时，误填写成分为两批发布。如果是热机状态，在正常情况下一半的机器可以勉强承载流量，但由于刚启动的JVM均是解释执行，还没有进行热点代码统计和JIT动态编译，导致机器启动之后，当前1/2发布成功的服务器马上全部宕机，此故障说明了JIT的存在。—**阿里团队**

<img src="https://npm.elemecdn.com/youthlql@1.0.8/JVM/chapter_008/0011.png">



### 3.4.5 JIT编译器相关概念

1. Java 语言的“编译期”其实是一段“不确定”的操作过程，因为它可能是指一个前端编译器（其实叫“编译器的前端”更准确一些）把.java文件转变成.class文件的过程。
2. 也可能是指虚拟机的后端运行期编译器（JIT编译器，Just In Time Compiler）把字节码转变成机器码的过程。
3. 还可能是指使用静态提前编译器（AOT编译器，Ahead of Time Compiler）直接把.java文件编译成本地机器代码的过程。（可能是后续发展的趋势）



**典型的编译器：**

1. 前端编译器：Sun的javac、Eclipse JDT中的增量式编译器（ECJ）。
2. JIT编译器：HotSpot VM的C1、C2编译器。
3. AOT 编译器：GNU Compiler for the Java（GCJ）、Excelsior JET。



### 3.4.6 热点代码及探测方式



1. 是否需要启动JIT编译器将字节码直接编译为对应平台的本地机器指令，需要根据代码被调用**执行的频率**而定。

2. 关于那些需要被编译为本地代码的字节码，也被称之为**“热点代码”**，JIT编译器在运行时会针对那些频繁被调用的“热点代码”做出**深度优化**，将其直接编译为对应平台的本地机器指令，以此提升Java程序的执行性能。

3. 一个被多次调用的方法，或者是一个方法体内部循环次数较多的循环体都可以被称之为“热点代码”，因此都可以通过JIT编译器编译为本地机器指令。由于这种编译方式发生在方法的执行过程中，因此也被称之为栈上替换，或简称为OSR (On StackReplacement)编译。

4. **目前HotSpot VM所采用的热点探测方式是基于计数器的热点探测**。

5. 采用基于计数器的热点探测，HotSpot VM将会为每一个方法都建立2个不同类型的计数器，分别为方法调用计数器（Invocation Counter）和回边计数器（Back Edge Counter）。

   - 方法调用计数器用于统计方法的调用次数

   - 回边计数器则用于统计循环体执行的循环次数



#### 3.4.6.1 方法调用计数器

1. 这个计数器就用于统计方法被调用的次数，它的默认阀值在Client模式下1500次，Server模式是10000次。超过这个阈值，就会触发JIT编译。
2. 这个阀值可以通过虚拟机参数 -XX:CompileThreshold 来人为设定。
3. 当一个方法被调用时，会先检查该方法是否存在被JIT编译过的版本
   - 如果存在，则优先使用编译后的本地代码来执行
   - 如果不存在已被编译过的版本，则将此方法的调用计数器值加1，然后判断方法调用计数器与回边计数器值之和是否超过方法调用计数器的阀值。
     - 如果已超过阈值，那么将会向即时编译器提交一个该方法的代码编译请求。
     - 如果未超过阈值，则使用解释器对字节码文件解释执行

<img src="https://npm.elemecdn.com/youthlql@1.0.8/JVM/chapter_008/0013.png" style="zoom:80%">



#### 3.4.6.2 热度衰减

1. 如果不做任何设置，方法调用计数器统计的并不是方法被调用的绝对次数，而是一个相对的执行频率，即**一段时间之内方法被调用的次数**。当超过一定的时间限度，如果方法的调用次数仍然不足以让它提交给即时编译器编译，那这个方法的调用计数器就会被减少一半，这个过程称为方法调用计数器热度的衰减（Counter Decay），而这段时间就称为此方法统计的半衰周期（Counter Half Life Time）（半衰周期是化学中的概念，比如出土的文物通过查看C60来获得文物的年龄）
2. **进行热度衰减的动作是在虚拟机进行垃圾收集时顺便进行的**，可以使用虚拟机参数 -XX:-UseCounterDecay 来关闭热度衰减，让方法计数器统计方法调用的绝对次数，这样的话，只要系统运行时间足够长，绝大部分方法都会被编译成本地代码。
3. 另外，可以使用-XX:CounterHalfLifeTime参数设置半衰周期的时间，单位是秒。



#### 3.4.6.3 回边计数器

它的作用是统计一个方法中循环体代码执行的次数，在字节码中遇到控制流向后跳转的指令称为“回边”（Back Edge）。显然，建立回边计数器统计的目的就是为了触发OSR编译。

<img src="https://npm.elemecdn.com/youthlql@1.0.8/JVM/chapter_008/0014.png" style="zoom:90%">



### 3.4.7 HotSpotVM可以设置程序执行方法

缺省情况下HotSpot VM是采用解释器与即时编译器并存的架构

1. -Xint：完全采用解释器模式执行程序；
2. -Xcomp：完全采用即时编译器模式执行程序。如果即时编译出现问题，解释器会介入执行
3. -Xmixed：采用解释器+即时编译器的混合模式共同执行程序。

只使用解释器程序执行非常慢





### 3.4.8 HotSpotVM JIT 分类

#### 3.4.8.1 认识

在HotSpot VM中内嵌有两个JIT编译器，分别为Client Compiler和Server Compiler，但大多数情况下我们简称为C1编译器 和 C2编译器。开发人员可以通过如下命令显式指定Java虚拟机在运行时到底使用哪一种即时编译器，如下所示：

1. -client：指定Java虚拟机运行在Client模式下，并使用C1编译器；
   - C1编译器会对字节码进行简单和可靠的优化，耗时短，以达到更快的编译速度。
2. -server：指定Java虚拟机运行在server模式下，并使用C2编译器。
   - C2进行耗时较长的优化，以及激进优化，但优化的代码执行效率更高。（使用C++）



#### 3.4.8.2 C1和C2编译器不同的优化策略

1. 在不同的编译器上有不同的优化策略，C1编译器上主要有方法内联，去虚拟化、元余消除。
   - 方法内联：将引用的函数代码编译到引用点处，这样可以减少栈帧的生成，减少参数传递以及跳转过程
   - 去虚拟化：对虚方法调用（`virtual`）进行类型推断，将动态调用变为直接调用，从而提高性能。
   - 冗余消除：在运行期间把一些不会执行的代码折叠掉
2. C2的优化主要是在全局层面，逃逸分析是优化的基础。基于逃逸分析在C2上有如下几种优化：
   - 标量替换：用标量值代替聚合对象的属性值
   - 栈上分配：对于未逃逸的对象分配对象在栈而不是堆
   - 同步消除：清除同步操作，通常指synchronized

> 也就是说之前的逃逸分析，只有在C2（server模式下）才会触发。那是否说明C1就用不了了？
>
> **不完全是。（这个是GPT的解释，下面也具体介绍了）**
>
> - **C1 仍然有用：**
>   - 在现代 JVM 中，通常会采用**分层编译**（Tiered Compilation）的方式，即结合 C1 和 C2 的优点。
>   - 程序启动时，JVM 使用解释器或 C1 编译器快速生成机器码，使应用快速进入运行状态。
>   - 随着程序运行，JVM 根据热点代码（频繁执行的代码）逐步触发 C2 编译器的深度优化。
> - **分层编译的优势：**
>   - 兼顾了快速启动和高性能运行：
>     - 初期由 C1 编译器生成轻量级优化代码。
>     - 热点代码再由 C2 编译器生成高性能代码。



#### 3.4.8.3 分层编译策略

1. 分层编译（Tiered Compilation）策略：程序解释执行（不开启性能监控）可以触发C1编译，将字节码编译成机器码，可以进行简单优化，也可以加上性能监控，C2编译会根据性能监控信息进行激进优化。
2. 不过在Java7版本之后，一旦开发人员在程序中显式指定命令“-server"时，默认将会开启分层编译策略，由C1编译器和C2编译器相互协作共同来执行编译任务。



#### 3.4.8.4 总结

1. 一般来讲，JIT编译出来的机器码性能比解释器解释执行的性能高
2. C2编译器启动时长比C1慢，系统稳定执行以后，C2编译器执行速度远快于C1编译器



#### 3.4.8.5 Java的其他编译器

#### （1）Graal 编译器

- 自JDK10起，HotSpot又加入了一个全新的即时编译器：Graal编译器

- 编译效果短短几年时间就追平了G2编译器，未来可期（对应还出现了Graal虚拟机，是有可能替代Hotspot的虚拟机的）

- 目前，带着实验状态标签，需要使用开关参数去激活才能使用

  -XX:+UnlockExperimentalvMOptions -XX:+UseJVMCICompiler



#### （2）AOT编译器

1. jdk9引入了AoT编译器（静态提前编译器，Ahead of Time Compiler）

2. Java 9引入了实验性AOT编译工具jaotc。它借助了Graal编译器，将所输入的Java类文件转换为机器码，并存放至生成的动态共享库之中。

3. 所谓AOT编译，是与即时编译相对立的一个概念。我们知道，即时编译指的是**在程序的运行过程中**，将字节码转换为可在硬件上直接运行的机器码，并部署至托管环境中的过程。而AOT编译指的则是，**在程序运行之前**，便将字节码转换为机器码的过程。

   .java -> .class -> (使用jaotc) -> .so



​	**AOT编译器编译器的优缺点**

​	**最大的好处：**

​		1. Java虚拟机加载已经预编译成二进制库，可以直接执行。

​		2. 不必等待即时编译器的预热，减少Java应用给人带来“第一次运行慢” 的不良体验

​	**缺点：**

​		1. 破坏了 java “ 一次编译，到处运行”，必须为每个不同的硬件，OS编译对应的发行包

​		2. 降低了Java链接过程的动态性，加载的代码在编译器就必须全部已知。

​		3. 还需要继续优化中，最初只支持Linux X64 java base