# JVM运行时数据区

# ===

# 1、运行时数据区概述及线程

## 1.1 运行时数据区结构

### 1.1.1 运行时数据区与内存

1. JVM内存布局规定了Java在运行过程中内存申请、分配、管理的策略，保证了JVM的高效稳定运行。**不同的JVM对于内存的划分方式和管理机制存在着部分差异**。

> 下图来自阿里巴巴手册JDK8

<img src="https://npm.elemecdn.com/youthlql@1.0.8/JVM/chapter_003/0004.jpg">



### 1.1.2 线程的内存空间

灰色的为单独线程私有的，红色的为多个线程共享的。即：

- 线程独有：独立包括程序计数器、栈、本地方法栈
- 线程间共享：堆、堆外内存（永久代或元空间、代码缓存）

<img src="https://npm.elemecdn.com/youthlql@1.0.8/JVM/chapter_003/0005.png">



### 1.1.3 Runtime类

**每个JVM只有一个Runtime实例**，即为运行时环境.



## 1.2 线程

### 1.2.1 JVM 线程

1. 线程是一个程序里的运行单元。JVM允许一个应用有多个线程并行的执行
2. **在Hotspot JVM里，每个线程都与操作系统的本地线程直接映射**
   - 当一个Java线程准备好执行以后，此时一个操作系统的本地线程也同时创建。Java线程执行终止后，本地线程也会回收
3. 操作系统负责将线程安排调度到任何一个可用的CPU上。一旦本地线程初始化成功，它就会调用Java线程中的run()方法



### 1.2.2 JVM 系统线程

- 如果你使用jconsole或者是任何一个调试工具，都能看到在后台有许多线程在运行。这些后台线程不包括调用`public static void main(String[])`的main线程以及所有这个main线程自己创建的线程。
- 这些主要的后台系统线程在Hotspot JVM里主要是以下几个：

1. **虚拟机线程**：这种线程的操作是需要JVM达到安全点才会出现。这些操作必须在不同的线程中发生的原因是他们都需要JVM达到安全点，这样堆才不会变化。这种线程的执行类型括"stop-the-world"的垃圾收集，线程栈收集，线程挂起以及偏向锁撤销
2. **周期任务线程**：这种线程是时间周期事件的体现（比如中断），他们一般用于周期性操作的调度执行
3. **GC线程**：这种线程对在JVM里不同种类的垃圾收集行为提供了支持
4. **编译线程**：这种线程在运行时会将字节码编译成到本地代码
5. **信号调度线程**：这种线程接收信号并发送给JVM，在它内部通过调用适当的方法进行处理







# ===

# 2、程序计数器(PC寄存器)

## 2.1 PC寄存器介绍

> 官方文档网址：https://docs.oracle.com/javase/specs/jvms/se8/html/index.html

<img src="https://npm.elemecdn.com/youthlql@1.0.8/JVM/chapter_003/0007.png">

1. **JVM中的PC寄存器是对物理PC寄存器的一种抽象模拟**。
2. 它是一块很小的内存空间，几乎可以忽略不记。也是运行速度最快的存储区域。
3. 在JVM规范中，每个线程都有它自己的程序计数器，是线程私有的，生命周期与线程的生命周期保持一致。
4. 任何时间一个线程都只有一个方法在执行，也就是所谓的**当前方法**。程序计数器会存储当前线程正在执行的Java方法的JVM指令地址；或者，如果是在执行native方法，则是未指定值（undefned）。
5. 它是**程序控制流**的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。
6. 字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。
7. 它是**唯一一个**在Java虚拟机规范中没有规定任何OutofMemoryError情况的区域。



## 2.2 PC寄存器的作用

PC寄存器用来存储指向下一条指令的地址，也即将要执行的指令代码。由执行引擎读取下一条指令，并执行该指令。

<img src="https://npm.elemecdn.com/youthlql@1.0.8/JVM/chapter_003/0008.png">

- 左边的数字代表**指令地址（指令偏移）**，即 PC 寄存器中可能存储的值，然后执行引擎读取 PC 寄存器中的值，并执行该指令

<img src="https://npm.elemecdn.com/youthlql@1.0.8/JVM/chapter_003/0009.png">



## 2.3 两个面试题

**使用PC寄存器存储字节码指令地址有什么用呢？**或者问**为什么使用 PC 寄存器来记录当前线程的执行地址呢？**

1. 因为CPU需要不停的切换各个线程，这时候切换回来以后，就得知道接着从哪开始继续执行
2. JVM的字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令

<img src="https://npm.elemecdn.com/youthlql@1.0.8/JVM/chapter_003/0010.png">



**PC寄存器为什么被设定为私有的？**

1. 我们都知道所谓的多线程在一个特定的时间段内只会执行其中某一个线程的方法，CPU会不停地做任务切换，这样必然导致经常中断或恢复，如何保证分毫无差呢？**为了能够准确地记录各个线程正在执行的当前字节码指令地址，最好的办法自然是为每一个线程都分配一个PC寄存器**，这样一来各个线程之间便可以进行独立计算，从而不会出现相互干扰的情况。
2. 由于CPU时间片轮限制，众多线程在并发执行过程中，任何一个确定的时刻，一个处理器或者多核处理器中的一个内核，只会执行某个线程中的一条指令。
3. 这样必然导致经常中断或恢复，如何保证分毫无差呢？每个线程在创建后，都会产生自己的程序计数器和栈帧，程序计数器在各个线程之间互不影响。

> 注意并行和并发的区别，第一部分GC里面有





# ===

# 3、本地方法接口&本地方法栈

## 3.1 本地方法

<img src="https://npm.elemecdn.com/youthlql@1.0.8/JVM/chapter_003/0012.png">



1. **Native Method是Java调用非Java代码的接囗**，Native Method的实现由非Java语言实现，比如C。这个特征并非Java所特有，很多其它的编程语言都有这一机制，比如在C++中，你可以用extern 告知C++编译器去调用一个C的函数。

2. “A native method is a Java method whose implementation is provided by non-java code.”

   （本地方法是一个非Java的方法，它的具体实现是非Java代码的实现）

3. 在定义一个native method时，并不提供实现体（有些像定义一个Java interface），因为其实现体是由非java语言在外面实现的。

4. 本地接口的作用是融合不同的编程语言为Java所用，它的初衷是融合C/C++程序。



## 3.2 为什么要使用 Native Method？

Java使用起来非常方便，然而有些层次的任务用Java实现起来不容易，或者我们对程序的效率很在意时，问题就来了。



### 3.2.1 与Java环境外交互

**有时Java应用需要与Java外面的硬件环境交互，这是本地方法存在的主要原因**。你可以想想Java需要与一些**底层系统**，如操作系统或某些硬件交换信息时的情况。本地方法正是这样一种交流机制：它为我们提供了一个非常简洁的接口，而且我们无需去了解Java应用之外的繁琐的细节。



### 3.2.2 与操作系统的交互

1. JVM支持着Java语言本身和运行时库，它是Java程序赖以生存的平台，它由一个解释器（解释字节码）和一些连接到本地代码的库组成。
2. 然而不管怎样，它毕竟不是一个完整的系统，它经常依赖于一底层系统的支持。这些底层系统常常是强大的操作系统。
3. **通过使用本地方法，我们得以用Java实现了jre的与底层系统的交互，甚至JVM的一些部分就是用C写的**。
4. 还有，如果我们要使用一些Java语言本身没有提供封装的操作系统的特性时，我们也需要使用本地方法。



## 3.3 Sun’s Java介绍

1. Sun的解释器是用C实现的，这使得它能像一些普通的C一样与外部交互。jre大部分是用Java实现的，它也通过一些本地方法与外界交互。
2. 例如：类java.lang.Thread的setPriority()方法是用Java实现的，但是它实现调用的是该类里的本地方法setPriority0()。这个本地方法是用C实现的，并被植入JVM内部在Windows 95的平台上，这个本地方法最终将调用Win32 setpriority() API。这是一个本地方法的具体实现由JVM直接提供，更多的情况是本地方法由外部的动态链接库（external dynamic link library）提供，然后被JVM调用。



## 3.4 本地方法的现状

目前该方法使用的越来越少了，除非是与硬件有关的应用，比如通过Java程序驱动打印机或者Java系统管理生产设备，在企业级应用中已经比较少见。因为现在的异构领域间的通信很发达，比如可以使用Socket通信，也可以使用Web Service等等，不多做介绍。



## 3.5 本地方法栈

1. **Java虚拟机栈于管理Java方法的调用，而本地方法栈用于管理本地方法的调用**。
2. 本地方法栈，也是线程私有的。
3. 允许被实现成固定或者是可动态扩展的内存大小（在内存溢出方面和虚拟机栈相同）
   - 如果线程请求分配的栈容量超过本地方法栈允许的最大容量，Java虚拟机将会抛出一个stackoverflowError 异常。
   - 如果本地方法栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的本地方法栈，那么Java虚拟机将会抛出一个outofMemoryError异常。
4. 本地方法一般是使用C语言或C++语言实现的。
5. 它的具体做法是Native Method Stack中登记native方法，在Execution Engine 执行时加载本地方法库。



**注意事项**

1. 当某个线程调用一个本地方法时，它就进入了一个全新的并且不再受虚拟机限制的世界。它和虚拟机拥有同样的权限。
   - 本地方法可以通过本地方法接口来访问虚拟机内部的运行时数据区
   - 它甚至可以直接使用本地处理器中的寄存器
   - 直接从本地内存的堆中分配任意数量的内存
2. 并不是所有的JVM都支持本地方法。因为Java虚拟机规范并没有明确要求本地方法栈的使用语言、具体实现方式、数据结构等。如果JVM产品不打算支持native方法，也可以无需实现本地方法栈。
3. 在Hotspot JVM中，直接将本地方法栈和虚拟机栈合二为一。







# ===

# 4、虚拟机栈

## 4.1 介绍

> 标题上打*号的是虚拟机栈中的主要内容

### 4.1.1 栈与堆的比较

1. 栈是运行时的单位，而堆是存储的单位。

2. 即：

   - 栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。

   - 堆解决的是数据存储的问题，即数据怎么放，放哪里

<img src="https://npm.elemecdn.com/youthlql@1.0.8/JVM/chapter_004/0001.png">



### 4.1.2 虚拟机栈基本内容

- 每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧（Stack Frame），**对应着一次次的Java方法调用**
- 栈是线程私有的

- 虚拟机栈的生命周期
  - 生命周期和线程一致，也就是线程结束了，该虚拟机栈也销毁了
- 虚拟机栈的作用
  - 主管Java程序的运行，保存方法的局部变量（8 种基本数据类型、对象的引用地址）、部分结果，并参与方法的调用和返回。
  - 局部变量，它是相比于成员变量来说的（或属性）

<img src="https://npm.elemecdn.com/youthlql@1.0.8/JVM/chapter_004/0002.png">



### 4.1.3 虚拟机栈的特点

- 栈是一种快速有效的分配存储方式，访问速度仅次于程序计数器。
- JVM直接对Java栈的操作只有两个：
  - 每个方法执行，伴随着**进栈**（入栈、压栈）
  - 执行结束后的**出栈**工作
- 对于栈来说不存在垃圾回收问题
  - 栈不需要GC，但是可能存在OOM

<img src="https://npm.elemecdn.com/youthlql@1.0.8/JVM/chapter_004/0003.png">



### 4.1.4 面试题：虚拟机栈可能出现的异常

- Java 虚拟机规范允许Java栈的大小是动态的或者是固定不变的。
  - 如果采用固定大小的Java虚拟机栈，那每一个线程的Java虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过Java虚拟机栈允许的最大容量，Java虚拟机将会抛出一个**StackoverflowError** 异常。
  - 如果Java虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那Java虚拟机将会抛出一个 **OutofMemoryError** 异常。



## 4.2 栈的存储单位

### 4.2.1 栈中存储什么？

1. 每个线程都有自己的栈，栈中的数据都是以**栈帧**（Stack Frame）的格式存在
2. 在这个线程上正在执行的每个方法都各自对应一个栈帧（Stack Frame）。
3. 栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息。



### 4.2.2 栈运行原理

1. JVM直接对Java栈的操作只有两个，就是对栈帧的**压栈和出栈**，遵循先进后出（后进先出）原则
2. 在一条活动线程中，一个时间点上，只会有一个活动的栈帧。即只有当前正在执行的方法的栈帧（栈顶栈帧）是有效的。这个栈帧被称为**当前栈帧（Current Frame）**，与当前栈帧相对应的方法就是**当前方法（Current Method）**，定义这个方法的类就是**当前类（Current Class）**
3. 执行引擎运行的所有字节码指令只针对当前栈帧进行操作。
4. 如果在该方法中调用了其他方法，对应的新的栈帧会被创建出来，放在栈的顶端，成为新的当前帧。

<img src="https://npm.elemecdn.com/youthlql@1.0.8/JVM/chapter_004/0005.png" style="zoom:80%">

**注意**

1. **不同线程中所包含的栈帧是不允许存在相互引用的**，即不可能在一个栈帧之中引用另外一个线程的栈帧。
2. 如果当前方法调用了其他方法，方法返回之际，当前栈帧会传回此方法的执行结果给前一个栈帧，接着，虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧。
3. Java方法有两种返回函数的方式，不管哪种方式，栈帧都会弹出。
   - 一种是正常的函数返回，使用return指令。
   - 另一种是方法执行中出现未捕获处理的异常，以抛出异常的方式结束。



### 4.2.3 栈帧的内部结构

每个栈帧中存储着：

- 局部变量表（Local Variables）
- 操作数栈（Operand Stack）（或表达式栈）
- 动态链接（Dynamic Linking）（或指向运行时常量池的方法引用）
- 方法返回地址（Return Address）（或方法正常退出或者异常退出的定义）
- 一些附加信息

<img src="https://npm.elemecdn.com/youthlql@1.0.8/JVM/chapter_004/0006.png">

并行每个线程下的栈都是私有的，因此每个线程都有自己各自的栈，并且每个栈里面都有很多栈帧，栈帧的大小主要由局部变量表 和 操作数栈决定的

<img src="https://npm.elemecdn.com/youthlql@1.0.8/JVM/chapter_004/0007.png">



## 4.3 局部变量表*

### 4.3.1 认识局部变量表

1. 局部变量表也被称之为局部变量数组或本地变量表
2. **局部变量表本质上是一个数据结构**，存储了方法参数和定义在方法体内的局部变量的具体值。
3. **定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量**，这些数据类型包括各类基本数据类型、对象引用（reference），以及returnAddress返回值类型。
4. 由于局部变量表是建立在线程的栈上，是线程的私有数据，因此**不存在数据安全问题**
5. **局部变量表所需的容量大小是在编译期确定下来的**，并保存在方法的Code属性的**maximum local variables**数据项中。在方法运行期间是不会改变局部变量表的大小的。
6. 方法嵌套调用的次数由栈的大小决定。一般来说，栈越大，方法嵌套调用次数越多。
7. 局部变量表中的变量只在当前方法调用中有效。
   - 在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程。
   - 当方法调用结束后，随着方法栈帧的销毁，局部变量表也会随之销毁。





### 4.3.2 认识Slot

1. slot是 JVM 中用于实现局部变量表的一种存储单元。
2. 参数值的存放总是从局部变量数组索引 0 的位置开始，到数组长度-1的索引结束。
3. 局部变量表，**最基本的存储单元是Slot（变量槽）**，局部变量表中存放编译期可知的各种基本数据类型（8种），引用类型（reference），returnAddress类型的变量。
4. 在局部变量表里，**32位以内的类型只占用一个slot**（包括returnAddress类型），**64位的类型占用两个slot**（long和double）。
   - byte、short、char在储存前被转换为int，boolean也被转换为int，0表示false，非0表示true
   - long和double则占据两个slot
5. JVM会为局部变量表中的每一个Slot都分配一个访问索引，通过这个索引即可成功访问到局部变量表中指定的局部变量值
6. 当一个实例方法被调用的时候，它的方法参数和方法体内部定义的局部变量将会**按照顺序被复制**到局部变量表中的每一个slot上
7. 如果需要访问局部变量表中一个64bit的局部变量值时，只需要使用前一个索引即可。（比如：访问long或double类型变量）
8. 如果当前帧是由构造方法或者实例方法创建的，那么**该对象引用this将会存放在index为0的slot处**，其余的参数按照参数表顺序继续排列。（this也相当于一个变量）

<img src="https://npm.elemecdn.com/youthlql@1.0.8/JVM/chapter_004/0014.png">



### 4.3.3 **static方法无法调用 this**

结合4.3.2的知识可知，this实际上是在局部变量表的index 0处的，而static方法是类方法，在元空间，所以static方法无法调用this

```java
    public static void testStatic(){
        LocalVariablesTest test = new LocalVariablesTest();
        Date date = new Date();
        int count = 10;
        System.out.println(count);
        //因为this变量不存在于当前方法的局部变量表中！！
//        System.out.println(this.count);
    }
```



### 4.3.4 Slot的重复利用

栈帧中的局部变量表中的槽位是可以重用的，如果一个局部变量过了其作用域，那么在其作用域之后申明新的局部变量变就很有可能会复用过期局部变量的槽位，从而达到节省资源的目的。

```java
    public void test4() {
        int a = 0;
        {
            int b = 0;
            b = a + 1;
        }
        //变量c使用之前已经销毁的变量b占据的slot的位置
        int c = a + 1;
    }
```

局部变量 c 重用了局部变量 b 的 slot 位置

<img src="https://npm.elemecdn.com/youthlql@1.0.8/JVM/chapter_004/0017.png">

**注意**：Slot采用的是覆盖利用的方式而不是删除，也就是说当一个Slot没用之后并不会被回收，而是等着后续需要用的时候直接写在这个Slot上进行覆盖，因此本地变量表的大小只会增加或不变，不会变小。





### 4.3.5 静态变量与局部变量的对比

```java
变量的分类：
1、按照数据类型分：
	- 基本数据类型  
	- 引用数据类型
2、按照在类中声明的位置分：
  2-1、成员变量：在使用前，都经历过默认初始化赋值
       2-1-1、类变量: linking的prepare阶段：给类变量默认赋值
              ---> initial阶段：给类变量显式赋值即静态代码块赋值
       2-1-2、实例变量：随着对象的创建，会在堆空间中分配实例变量空间，并进行默认赋值
  2-2、局部变量：在使用前，必须要进行显式赋值的！否则，编译不通过。
```

1. 参数表分配完毕之后，再根据方法体内定义的变量的顺序和作用域分配。
2. 我们知道成员变量有两次初始化的机会**，**第一次是在“准备阶段”，执行系统初始化，对类变量设置零值，另一次则是在“初始化”阶段，赋予程序员在代码中定义的初始值。
3. 和类变量初始化不同的是，**局部变量表不存在系统初始化的过程**，这意味着一旦定义了局部变量则必须人为的初始化，否则无法使用。



### 4.3.6 补充说明

1. 在栈帧中，与性能调优关系最为密切的部分就是局部变量表。在方法执行时，虚拟机使用局部变量表完成方法的传递。
2. 局部变量表中的变量也是重要的垃圾回收根节点（GC Roots），只要被局部变量表中直接或间接引用的对象都不会被回收。



## 4.4 操作数栈*

### 4.4.1 操作数栈的特点

1. 每一个独立的栈帧除了包含局部变量表以外，还包含一个后进先出（Last - In - First -Out）的 操作数栈，也可以称之为**表达式栈**（Expression Stack）
2. 操作数栈，在方法执行过程中，**根据字节码指令，往栈中写入数据或提取数据**，即入栈（push）和 出栈（pop）

- 某些字节码指令将值压入操作数栈，其余的字节码指令将操作数取出栈。使用它们后再把结果压入栈，
- 比如：执行复制、交换、求和等操作

<img src="https://npm.elemecdn.com/youthlql@1.0.8/JVM/chapter_004/0018.png" style="zoom:80%">



### 4.4.2 操作数栈的作用

1. 操作数栈，**主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间**。
2. 每一个操作数栈都会拥有一个明确的栈深度用于存储数值，其所需的最大深度在编译期就定义好了，保存在方法的Code属性中，为**maxstack**的值。
3. 栈中的任何一个元素都是可以任意的Java数据类型
   - 32bit的类型占用一个栈单位深度
   - 64bit的类型占用两个栈单位深度
4. 操作数栈只能通过标准的入栈和出栈操作来完成一次数据访问，**只不过操作数栈是用数组这个结构来实现的而已**
5. 如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中，并更新PC寄存器中下一条需要执行的字节码指令。
6. 操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，这由编译器在编译器期间进行验证，同时在类加载过程中的类检验阶段的数据流分析阶段要再次验证。
7. **我们说Java虚拟机的解释引擎是基于栈的执行引擎，其中的栈指的就是操作数栈**。



### 4.4.3 **数据入栈时类型转换的说明**

<img src="https://npm.elemecdn.com/youthlql@1.0.8/JVM/chapter_004/0027.png" style="zoom:45%">

- 因为 8 可以存放在 byte 类型中，所以压入操作数栈的类型为 byte ，而不是 int ，所以执行的字节码指令为 bipush 8
- 但是存储在局部变量的时候，会转成 int 类型的变量：istore_4

<img src="https://npm.elemecdn.com/youthlql@1.0.8/JVM/chapter_004/0028.png" style="zoom:50%">

- m改成800之后，byte存储不了，就成了short型，sipush 800



## 4.5 栈顶缓存技术

**栈顶缓存技术：Top Of Stack Cashing**

1. 前面提过，基于栈式架构的虚拟机所使用的零地址指令更加紧凑，但完成一项操作的时候必然需要使用更多的入栈和出栈指令，这同时也就意味着将需要更多的指令分派（instruction dispatch）次数（也就是你会发现指令很多）和导致内存读/写次数多，效率不高。
2. 由于操作数是存储在内存中的，因此频繁地执行内存读/写操作必然会影响执行速度。为了解决这个问题，HotSpot JVM的设计者们提出了栈顶缓存（Tos，Top-of-Stack Cashing）技术，**将栈顶元素全部缓存在物理CPU的寄存器中，以此降低对内存的读/写次数，提升执行引擎的执行效率。**
3. 寄存器的主要优点：指令更少，执行速度快，但是指令集（也就是指令种类）很多

> 所以虽然HotSpot是基于栈的JVM，但是通过栈顶缓存技术实现了对执行引擎执行效率的提升，算是吸收了基于寄存器的JVM的优点。



## 4.6 动态链接*（或指向运行时常量池的方法引用）

1. 每一个栈帧内部都包含**一个指向运行时常量池中该栈帧所属方法的引用**。包含这个引用的目的就是**为了支持当前方法的代码能够实现动态链接**（Dynamic Linking），比如：invokedynamic指令
2. 在Java源文件被编译到字节码文件中时，所有的变量和方法引用都作为符号引用（Symbolic Reference）保存在class文件的常量池里。比如：描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么**动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用**



```java
public class DynamicLinkingTest {

    int num = 10;

    public void methodA(){
        System.out.println("methodA()....");
    }

    public void methodB(){
        System.out.println("methodB()....");

        methodA();

        num++;
    }

}
```

<img src="https://npm.elemecdn.com/youthlql@1.0.8/JVM/chapter_004/0031.png">



## 4.7 **常量池的作用**（常量池不属于栈）

1. 在不同的方法，都可能调用常量或者方法，所以只需要存储一份即可，然后记录其引用即可，节省了空间。
2. 常量池的作用：就是为了提供一些符号和常量，便于指令的识别
3. 在class文件和JVM中都有常量池，JVM中的常量池叫做运行时常量池，主要存储从class文件中加载的常量和运行过程中的常量，比如字符串常量。



## 4.8 方法的调用

### 4.8.1 静态链接与动态链接

在JVM中，将符号引用转换为调用方法的直接引用与方法的绑定机制相关

- **静态链接**：当一个字节码文件被装载进JVM内部时，如果被调用的目标方法在编译期确定，且运行期保持不变时，这种情况下将调用方法的符号引用转换为直接引用的过程称之为静态链接

- **动态链接**：如果被调用的方法在编译期无法被确定下来，也就是说，只能够在程序运行期将调用的方法的符号转换为直接引用，由于这种引用转换过程具备动态性，因此也被称之为动态链接。



### 4.8.2 早期绑定与晚期绑定

> 静态链接与动态链接针对的是方法。早期绑定和晚期绑定范围更广。早期绑定涵盖了静态链接，晚期绑定涵盖了动态链接。

静态链接和动态链接对应的方法的绑定机制为：早期绑定（Early Binding）和晚期绑定（Late Binding）。**绑定是一个字段、方法或者类在符号引用被替换为直接引用的过程**，这仅仅发生一次。

- **早期绑定**：早期绑定就是指被调用的目标方法如果在编译期可知，且运行期保持不变时，即可将这个方法与所属的类型进行绑定，这样一来，由于明确了被调用的目标方法究竟是哪一个，因此也就**可以使用静态链接的方式将符号引用转换为直接引用**。

- **晚期绑定**：如果被调用的方法在编译期无法被确定下来，**只能够在程序运行期根据实际的类型绑定相关的方法**，这种绑定方式也就被称之为晚期绑定。



### 4.8.3 多态与绑定

#### （1）虚方法与非虚方法

1. 如果方法在编译期就确定了具体的调用版本，这个版本在运行时是不可变的。这样的方法称为非虚方法。
2. 静态方法、私有方法、final方法、实例构造器、父类方法都是非虚方法。
3. 其他方法称为虚方法。



#### **（2）子类对象的多态的使用前提：**

1. 类的继承关系
2. 方法的重写



### 4.8.4 动态语言和静态语言

1. 两者的区别在于**对类型的检查是在编译期还是在运行期**，满足前者就是静态类型语言，反之是动态类型语言。
2. 静态类型语言是判断变量自身的类型信息；动态类型语言是判断变量值的类型信息，变量没有类型信息，变量值才有类型信息，这是动态语言的一个重要特征。
3. Java是静态语言，Python是动态语言。



### 4.8.5 虚方法表

> Java重写方法的调用涉及到的技术是动态分派

1. 在面向对象的编程中，会很频繁的使用到**动态分派**，如果在每次动态分派的过程中都要重新在类的方法元数据中搜索合适的目标的话就可能影响到执行效率。（因为子类没找到就要自下而上全找完）
2. 为了提高性能，**JVM采用在类的方法区建立一个虚方法表（virtual method table）来实现**，非虚方法不会出现在表中。使用索引表来代替查找。
3. 每个**类**中都有一个虚方法表，表中存放着各个方法的实际入口。
4. 虚方法表会在类加载的**链接阶段被创建并开始初始化**，类的变量初始值准备完成之后，JVM会把该类的虚方法表也初始化完毕。

  



## 4.9 方法返回地址*

<img src="https://npm.elemecdn.com/youthlql@1.0.8/JVM/chapter_004/0039.png">

> 在一些帖子里，方法返回地址、动态链接、一些附加信息  也叫做帧数据区

1. 存放调用该方法的pc寄存器的值。一个方法的结束，有两种方式：
   - 正常执行完成
   - 出现未处理的异常，非正常退出
2. 方法正常退出时，**调用者的pc计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址**。而通过异常退出的，返回地址是要通过异常表来确定，栈帧中一般不会保存这部分信息。
3. 本质上，方法的退出就是当前栈帧出栈的过程。此时，需要恢复上层方法的局部变量表、操作数栈、将返回值压入调用者栈帧的操作数栈、设置PC寄存器值等，让调用者方法继续执行下去。
4. 正常完成出口和异常完成出口的区别在于：通过异常完成出口退出的不会给他的上层调用者产生任何的返回值。



## 4.10 一些附加信息*

栈帧中还允许携带与Java虚拟机实现相关的一些附加信息。例如：对程序调试提供支持的信息。



## 4.11 栈相关面试题

### 4.11.1 举例栈溢出的情况？

SOF（StackOverflowError），栈大小分为固定的，和动态变化。如果是固定的就可能出现StackOverflowError。如果是动态变化的，内存不足时就可能出现OOM



### 4.11.2 调整栈大小，就能保证不出现溢出么？

不能保证不溢出，只能保证SOF出现的几率小



### 4.11.3 分配的栈内存越大越好么？

不是，一定时间内降低了OOM概率，但是会挤占其它的线程空间，因为整个虚拟机的内存空间是有限的



### 4.11.4 垃圾回收是否涉及到虚拟机栈？

不会

| 位置                                        | 是否有Error | 是否存在GC |
| ------------------------------------------- | ----------- | ---------- |
| PC计数器                                    | 无          | 不存在     |
| 虚拟机栈                                    | 有，SOF     | 不存在     |
| 本地方法栈(在HotSpot的实现中和虚拟机栈一样) | 有，SOF     | 不存在     |
| 堆                                          | 有，OOM     | 存在       |
| 方法区                                      | 有          | 存在       |



### 4.11.5 方法中定义的局部变量是否线程安全？

**具体问题具体分析**

1. 如果只有一个线程才可以操作此数据，则必是线程安全的。
2. 如果有多个线程操作此数据，则此数据是共享数据。如果不考虑同步机制的话，会存在线程安全问题。

**具体问题具体分析：**

- 如果对象是在内部产生，并在内部消亡，没有返回到外部，那么它就是线程安全的，反之则是线程不安全的。





# ===

# 5、堆

## 5.1 堆的核心概述

### 5.1.1 堆与进程

1. 一个JVM实例只存在一个堆内存，堆也是Java内存管理的核心区域。
2. Java堆区在JVM启动的时候即被创建，其空间大小也就确定了，堆是JVM管理的最大一块内存空间，并且堆内存的大小是可以调节的。
3. 《Java虚拟机规范》规定，堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的。
4. 所有的线程共享Java堆，在这里还可以划分线程私有的缓冲区（Thread Local Allocation Buffer，**TLAB**）。
5. 《Java虚拟机规范》中对Java堆的描述是：**所有的对象实例以及数组都应当在运行时分配在堆上**。（The heap is the run-time data area from which memory for all class instances and arrays is allocated）
   - 从实际使用角度看：“几乎”所有的对象实例都在堆分配内存，但并非全部。因为还有一些对象是在栈上分配的（逃逸分析，标量替换）
6. 数组和对象可能永远不会存储在栈上（**不一定**），因为栈帧中保存引用，这个引用指向对象或者数组在堆中的位置。
7. 在方法结束后，堆中的对象不会马上被移除，仅仅在垃圾收集的时候才会被移除。
   - 也就是触发了GC的时候，才会进行回收
   - 如果堆中对象马上被回收，那么用户线程就会收到影响，因为有stop the word
8. 堆，是GC（Garbage Collection，垃圾收集器）执行垃圾回收的重点区域。

> 随着JVM的迭代升级，原来一些绝对的事情，在后续版本中也开始有了特例，变的不再那么绝对。

<img src="https://npm.elemecdn.com/youthlql@1.0.8/JVM/chapter_005/0002.png" style="zoom:80%">



### 5.1.2 堆内存细分

约定：新生区 <–> 新生代 <–> 年轻代 、 养老区 <–> 老年区 <–> 老年代、 永久区 <–\> 永久代

<img src="https://npm.elemecdn.com/youthlql@1.0.8/JVM/chapter_005/0003.png" style="zoom:70%">



堆空间内部结构，JDK1.8从永久代 替换成 元空间

<img src="https://npm.elemecdn.com/youthlql@1.0.8/JVM/chapter_005/0004.png" style="zoom:60%">



## 5.2 设置堆内存大小

1. Java堆区用于存储Java对象实例，那么堆的大小在JVM启动时就已经设定好了，大家可以通过选项"-Xms"和"-Xmx"来进行设置。
   - **-Xms**用于表示堆区的起始内存，等价于**-XX:InitialHeapSize**
   - **-Xmx**则用于表示堆区的最大内存，等价于**-XX:MaxHeapSize**
2. 一旦堆区中的内存大小超过“-Xmx"所指定的最大内存时，将会抛出OutofMemoryError异常。
3. 通常会将-Xms和-Xmx两个参数配置相同的值

- 原因：假设两个不一样，初始内存小，最大内存大。在运行期间如果堆内存不够用了，会一直扩容直到最大内存。如果内存够用且多了，也会不断的缩容释放。频繁的扩容和释放造成不必要的压力，避免在GC之后调整堆内存给服务器带来压力。
- 如果两个设置一样的就少了频繁扩容和缩容的步骤。内存不够了就直接报OOM

4. 默认情况下:
   - 初始内存大小：物理电脑内存大小/64
   - 最大内存大小：物理电脑内存大小/4



## 5.3 年轻代与老年代

**年轻代与老年代**

1、存储在JVM中的Java对象可以被划分为两类：

```
- 一类是生命周期较短的瞬时对象，这类对象的创建和消亡都非常迅速
- 另外一类对象的生命周期却非常长，在某些极端的情况下还能够与JVM的生命周期保持一致
```

2、Java堆区进一步细分的话，可以划分为年轻代（YoungGen）和老年代（oldGen）

3、年轻代又划分为Eden空间、Survivor0空间和Survivor1空间（有时也叫做from区、to区）

<img src="https://npm.elemecdn.com/youthlql@1.0.8/JVM/chapter_005/0013.png">

<img src="https://npm.elemecdn.com/youthlql@1.0.8/JVM/chapter_005/0014.png" style="zoom:60%">

- 配置新生代与老年代在堆结构的占比
  - 默认**-XX:NewRatio**=2，表示新生代占1，老年代占2，新生代占整个堆的1/3
  - 可以修改**-XX:NewRatio**=4，表示新生代占1，老年代占4，新生代占整个堆的1/5



**年轻代的具体结构**

1. 在HotSpot中，Eden空间和另外两个survivor空间缺省所占的比例是8 : 1 : 1，
2. 当然开发人员可以通过选项**-XX:SurvivorRatio**调整这个空间比例。比如-XX:SurvivorRatio=8
3. 几乎所有的Java对象都是在Eden区被new出来的。
4. 绝大部分的Java对象的销毁都在新生代进行了（有些大的对象在Eden区无法存储时候，将直接进入老年代），IBM公司的专门研究表明，新生代中80%的对象都是“朝生夕死”的。
5. 可以使用选项"-Xmn"设置新生代最大内存大小，但这个参数一般使用默认值就可以了。

<img src="https://npm.elemecdn.com/youthlql@1.0.8/JVM/chapter_005/0015.png" style="zoom:70%">



## 5.4 对象内存分配

### 5.4.1 对象内存分配策略

1. 如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并将对象年龄设为1。
2. 对象在Survivor区中每熬过一次MinorGC，年龄就增加1岁，当它的年龄增加到一定程度（默认为15岁，其实每个JVM、每个GC都有所不同）时，就会被晋升到老年代
3. 对象晋升老年代的年龄阀值，可以通过选项**-XX:MaxTenuringThreshold**来设置



**针对不同年龄段的对象分配原则如下所示：**

1. **优先分配到Eden**：开发中比较长的字符串或者数组，会直接存在老年代，但是因为新创建的对象都是朝生夕死的，所以这个大对象可能也很快被回收，但是因为老年代触发Major GC的次数比 Minor GC要更少，因此可能回收起来就会比较慢
2. **大对象直接分配到老年代**：尽量避免程序中出现过多的大对象
3. **长期存活的对象分配到老年代**
4. **动态对象年龄判断**：如果Survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄。
5. **空间分配担保**： -XX:HandlePromotionFailure 。



### 5.4.2 对象内存分配过程（一般情况）

1. new的对象先放伊甸园区。此区有大小限制。
2. 当伊甸园的空间填满时，程序又需要创建对象，JVM的垃圾回收器将对伊甸园区进行垃圾回收（MinorGC），将伊甸园区中的不再被其他对象所引用的对象进行销毁。再加载新的对象放到伊甸园区。
3. 然后将伊甸园中的剩余对象移动到幸存者0区。
4. 如果再次触发垃圾回收，此时上次幸存下来的放到幸存者0区的，如果没有回收，就会放到幸存者1区。
5. 如果再次经历垃圾回收，此时会重新放回幸存者0区，接着再去幸存者1区。
6. 啥时候能去养老区呢？可以设置次数。默认是15次。可以设置新生区进入养老区的年龄限制，设置 JVM 参数：**-XX:MaxTenuringThreshold**=N 进行设置
7. 在养老区，相对悠闲。当养老区内存不足时，再次触发GC：Major GC，进行养老区的内存清理
8. 若养老区执行了Major GC之后，发现依然无法进行对象的保存，就会产生OOM异常。



### 5.4.3 TLAB为对象分配内存（保证线程安全）

#### 5.4.3.1 为什么有 TLAB

1. 堆区是线程共享区域，任何线程都可以访问到堆区中的共享数据
2. 由于对象实例的创建在JVM中非常频繁，因此在并发环境下从堆区中划分内存空间是线程不安全的
3. 为避免多个线程操作同一地址，需要使用**加锁等机制**，进而影响分配速度。



#### 5.4.3.2 什么是 TLAB

TLAB（Thread Local Allocation Buffer）

1. 从内存模型而不是垃圾收集的角度，对Eden区域继续进行划分，**JVM为每个线程分配了一个私有缓存区域，它包含在Eden空间内**。
2. 多线程同时分配内存时，使用TLAB可以避免一系列的非线程安全问题，同时还能够提升内存分配的吞吐量，因此我们可以将这种内存分配方式称之为**快速分配策略**。
3. 据我所知所有OpenJDK衍生出来的JVM都提供了TLAB的设计。

<img src="https://npm.elemecdn.com/youthlql@1.0.8/JVM/chapter_005/0023.png">

1、每个线程都有一个TLAB空间

2、当一个线程的TLAB存满时，可以使用公共区域（蓝色）的



#### 5.4.3.3 TLAB再说明

1. 尽管不是所有的对象实例都能够在TLAB中成功分配内存，但**JVM确实是将TLAB作为内存分配的首选**。
2. 在程序中，开发人员可以通过选项“**-XX:UseTLAB**”设置是否开启TLAB空间。
3. 默认情况下，TLAB空间的内存非常小，仅占有整个Eden空间的1%，当然我们可以通过选项“**-XX:TLABWasteTargetPercent**”设置TLAB空间所占用Eden空间的百分比大小。
4. 一旦对象在TLAB空间分配内存失败时，JVM就会尝试着通过**使用加锁机制确保数据操作的原子性**，从而直接在Eden空间中分配内存。



### 5.4.4 空间分配担保

在发生Minor GC之前，虚拟机会检查老年代最大可用的连续空间是否大于新生代所有对象的总空间。

- 如果大于，则此次Minor GC是安全的

- 如果小于，则虚拟机会查看**-XX:HandlePromotionFailure**设置值是否允担保失败。

  - 如果HandlePromotionFailure=true，那么会继续检查**老年代最大可用连续空间是否大于历次晋升到老年代的对象的平均大小**。
    - 如果大于，则尝试进行一次Minor GC，但这次Minor GC依然是有风险的；
    - 如果小于，则进行一次Full GC。
  - 如果HandlePromotionFailure=false，则进行一次Full GC。

  

**历史版本**

1. 在JDK6 Update 24之后，HandlePromotionFailure参数不会再影响到虚拟机的空间分配担保策略，观察openJDK中的源码变化，虽然源码中还定义了HandlePromotionFailure参数，但是在代码中已经不会再使用它。
2. JDK6 Update 24之后的规则变为**只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行Minor GC**，否则将进行Full GC。即 HandlePromotionFailure=true



## 5.5 GC分类

### 5.5.1 认识

1. **Major GC 和 Full GC出现STW的时间，是Minor GC的10倍以上**
2. JVM在进行GC时，并非每次都对上面三个内存区域一起回收的，大部分时候回收的都是指新生代。针对Hotspot VM的实现，它里面的GC按照回收区域又分为两大种类型：一种是部分收集（Partial GC），一种是整堆收集（FullGC）

- 部分收集：不是完整收集整个Java堆的垃圾收集。其中又分为：
  - **新生代收集**（Minor GC/Young GC）：只是新生代（Eden，s0，s1）的垃圾收集
  - **老年代收集**（Major GC/Old GC）：只是老年代的圾收集。
  - 目前，只有CMS GC会有单独收集老年代的行为。
  - 注意，很多时候Major GC会和Full GC混淆使用，需要具体分辨是老年代回收还是整堆回收。
  - 混合收集（Mixed GC）：收集整个新生代以及部分老年代的垃圾收集。目前，只有G1 GC会有这种行为
- **整堆收集**（Full GC）：收集整个java堆和方法区的垃圾收集。

> 由于历史原因，外界各种解读，majorGC和Full GC有些混淆。



### 5.5.2 Young GC

**年轻代 GC（Minor GC）触发机制**

1. 当年轻代空间不足时，就会触发Minor GC，这里的年轻代满指的是Eden代满。Survivor满不会主动引发GC，在Eden区满的时候，会顺带触发s0区的GC，也就是被动触发GC（每次Minor GC会清理年轻代的内存）
2. 因为Java对象大多都具备朝生夕灭的特性，所以Minor GC非常频繁，一般回收速度也比较快。这一定义既清晰又易于理解。
3. Minor GC会引发STW（Stop The World），暂停其它用户的线程，等垃圾回收结束，用户线程才恢复运行

<img src="https://npm.elemecdn.com/youthlql@1.0.8/JVM/chapter_005/0020.png" style="zoom:55%">



### 5.5.3 Major/Full GC

#### 5.5.3.1 **老年代GC（MajorGC）触发机制**

1. 指发生在老年代的GC，对象从老年代消失时，我们说 “Major Gc” 或 “Full GC” 发生了
2. 出现了MajorGc，经常会伴随至少一次的Minor GC。（但非绝对的，在Parallel Scavenge收集器的收集策略里就有直接进行MajorGC的策略选择过程）
   - 也就是在老年代空间不足时，会先尝试触发Minor GC（哈？我有点迷？），如果之后空间还不足，则触发Major GC
3. Major GC的速度一般会比Minor GC慢10倍以上，STW的时间更长。
4. 如果Major GC后，内存还不足，就报OOM了



#### 5.5.3.2 **触发Full GC执行的情况有如下五种：**

1. 调用System.gc()时，系统建议执行FullGC，但是不必然执行
2. 老年代空间不足
3. 方法区空间不足
4. 通过Minor GC后进入老年代的平均大小大于老年代的可用内存
5. 由Eden区、survivor space0（From Space）区向survivor space1（To Space）区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小

说明：Full GC 是开发或调优中尽量要避免的。这样STW时间会短一些



## 5.6 堆是分配对象的唯一选择么？

**在《深入理解Java虚拟机》中关于Java堆内存有这样一段描述：**

1. 随着JIT编译期的发展与**逃逸分析技术**逐渐成熟，**栈上分配、标量替换**优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。
2. 在Java虚拟机中，对象是在Java堆中分配内存的，这是一个普遍的常识。但是，有一种特殊情况，那就是**如果经过逃逸分析（Escape Analysis）后发现，一个对象并没有逃逸出方法的话，那么就可能被优化成栈上分配**。这样就无需在堆上分配内存，也无须进行垃圾回收了。这也是最常见的堆外存储技术。
3. 此外，前面提到的基于OpenJDK深度定制的TaoBao VM，其中创新的GCIH（GC invisible heap）技术实现off-heap，将生命周期较长的Java对象从heap中移至heap外，并且GC不能管理GCIH内部的Java对象，以此达到降低GC的回收频率和提升GC的回收效率的目的。



### 5.6.1 逃逸分析

1. 这是一种可以有效减少Java程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法。
2. 通过逃逸分析，Java Hotspot编译器能够分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上。
3. 逃逸分析的基本行为就是分析对象动态作用域：
   - 当一个对象在方法中被定义后，对象只在方法内部使用，则认为没有发生逃逸。
   - 当一个对象在方法中被定义后，它被外部方法所引用，则认为发生逃逸。例如作为调用参数传递到其他地方中。



**逃逸分析参数设置**

1. 在JDK 1.7 版本之后，HotSpot中默认就已经开启了逃逸分析
2. 如果使用的是较早的版本，开发人员则可以通过：
   - 选项“-XX:+DoEscapeAnalysis"显式开启逃逸分析
   - 通过选项“-XX:+PrintEscapeAnalysis"查看逃逸分析的筛选结果



### 5.6.2 代码优化

使用逃逸分析，编译器可以对代码做如下优化：

> 关于逃逸分析，在JVM运行引擎部分有介绍，具体在C1、C2编译器那里。

1. **栈上分配**：将堆分配转化为栈分配。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会发生逃逸，对象可能是栈上分配的候选，而不是堆上分配
2. **同步省略**：如果一个对象被发现只有一个线程被访问到，那么对于这个对象的操作可以不考虑同步。
3. **分离对象或标量替换**：有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在内存，而是存储在CPU寄存器中。



#### 5.6.2.1 栈上分配

1. JIT编译器在编译期间根据逃逸分析的结果，发现如果一个对象并没有逃逸出方法的话，就可能被优化成栈上分配。分配完成后，继续在调用栈内执行，最后线程结束，栈空间被回收，局部变量对象也被回收。这样就无须进行垃圾回收了。
2. 常见的栈上分配的场景：在逃逸分析中，已经说明了，分别是给成员变量赋值、方法返回值、实例引用传递。



#### 5.6.2.2 同步省略（同步消除）

1. 线程同步的代价是相当高的，同步的后果是降低并发性和性能。
2. 在动态编译同步块的时候，JIT编译器可以借助逃逸分析来**判断同步块所使用的锁对象是否只能够被一个线程访问而没有被发布到其他线程**。
3. 如果没有，那么JIT编译器在编译这个同步块的时候就会取消对这部分代码的同步。这样就能大大提高并发性和性能。这个**取消同步的过程就叫同步省略，也叫锁消除**。



#### 5.6.2.3 标量替换

**分离对象或标量替换**

1. 标量（scalar）是指一个无法再分解成更小的数据的数据。Java中的原始数据类型就是标量。
2. 相对的，那些还可以分解的数据叫做聚合量（Aggregate），Java中的对象就是聚合量，因为他可以分解成其他聚合量和标量。
3. 在JIT阶段，如果经过逃逸分析，发现一个对象不会被外界访问的话，那么经过JIT优化，就会把这个对象拆解成若干个其中包含的若干个成员变量来代替。这个过程就是标量替换。



**标量替换举例**

代码

```java
public static void main(String args[]) {
    alloc();
}
private static void alloc() {
    Point point = new Point(1,2);
    System.out.println("point.x" + point.x + ";point.y" + point.y);
}
class Point {
    private int x;
    private int y;
}
```



以上代码，经过标量替换后，就会变成

```java
private static void alloc() {
    int x = 1;
    int y = 2;
    System.out.println("point.x = " + x + "; point.y=" + y);
}
```



1. 可以看到，Point这个聚合量经过逃逸分析后，发现他并没有逃逸，就被替换成两个聚合量了。
2. 那么标量替换有什么好处呢？就是可以大大减少堆内存的占用。因为一旦不需要创建对象了，那么就不再需要分配堆内存了。
3. 标量替换为栈上分配提供了很好的基础。



### 5.6.3 逃逸分析的不足

1. 无法保证逃逸分析的性能消耗一定能高于他的消耗。虽然经过逃逸分析可以做标量替换、栈上分配、和锁消除。但是逃逸分析自身也是需要进行一系列复杂的分析的，这其实也是一个相对耗时的过程。
2. 一个极端的例子，就是经过逃逸分析之后，发现没有一个对象是不逃逸的。那这个逃逸分析的过程就白白浪费掉了。
3. 虽然这项技术并不十分成熟，但是它也是即时编译器优化技术中一个十分重要的手段。
4. 注意到有一些观点，认为通过逃逸分析，JVM会在栈上分配那些不会逃逸的对象，这在理论上是可行的，但是取决于JVM设计者的选择。据我所知，**Oracle Hotspot JVM中并未这么做**，这一点在逃逸分析相关的文档里已经说明，**所以可以明确在HotSpot虚拟机上，所有的对象实例都是创建在堆上**。
5. 目前很多书籍还是基于JDK7以前的版本，JDK已经发生了很大变化，intern字符串的缓存和静态变量曾经都被分配在永久代上，而永久代已经被元数据区取代。但是**intern字符串缓存和静态变量并不是被转移到元数据区，而是直接在堆上分配**，**所以这一点同样符合前面一点的结论：对象实例都是分配在堆上**。



> **堆是分配对象的唯一选择么？**

综上：**对象实例都是分配在堆上**。



# ===

# 6、方法区

## 6.1 栈、堆、方法区的交互关系

> ##### 理解一个对象是如何分配在运行时数据区的各个部分的

**从线程共享与否的角度来看**

ThreadLocal：如何保证多个线程在并发环境下的安全性？典型场景就是数据库连接管理，以及会话管理。

<img src="https://npm.elemecdn.com/youthlql@1.0.8/JVM/chapter_006/0001.png">

**栈、堆、方法区的交互关系**

**下面涉及了对象的访问定位**

1. Person 类的 .class 信息存放在方法区中
2. person 变量存放在 Java 栈的局部变量表中
3. 真正的 person 对象存放在 Java 堆中
4. 在 person 对象中，有个指针指向方法区中的 person 类型数据，表明这个 person 对象是用方法区中的 Person 类 new 出来的

<img src="https://npm.elemecdn.com/youthlql@1.0.8/JVM/chapter_006/0002.png">



## 6.2 方法区的理解

> **官方文档**：https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.5.4

### 6.2.1 方法区在哪里？

1. 对于HotSpotJVM而言，方法区还有一个别名叫做Non-Heap（非堆），目的就是要和堆分开。
2. **方法区可以看作是一块独立于Java堆的内存空间**

<img src="https://npm.elemecdn.com/youthlql@1.0.8/JVM/chapter_006/0003.png">



### 6.2.2 方法区的基本理解

**方法区主要存放的是 Class，而堆中主要存放的是实例化的对象**

1. 方法区（Method Area）是各个线程共享的内存区域。多个线程同时加载同一个类时，只能有一个线程能加载该类，其他线程只能等待该线程加载完毕，然后直接使用该类，即类只能加载一次。
2. 方法区在JVM启动的时候被创建，它的实际的物理内存空间中可以是不连续的，逻辑上连续即可。
3. 方法区的大小，跟堆空间一样，可以选择固定大小或者可扩展。
4. 方法区的大小决定了系统可以保存多少个类，如果方法区溢出，虚拟机会抛出内存溢出错误：`java.lang.OutofMemoryError:PermGen space`或者`java.lang.OutOfMemoryError:Metaspace`
   - 加载大量的第三方的jar包
   - Tomcat部署的工程过多（30~50个）
   - 大量动态的生成反射类
5. 关闭JVM就会释放这个区域的内存。



### 6.2.3 HotSpot方法区演进

1. 在 JDK7 及以前，习惯上把方法区，称为永久代。JDK8开始，使用元空间取代了永久代。
2. 本质上，方法区和永久代并不等价。仅是对Hotspot而言的可以看作等价。
   - 现在来看，当年使用永久代，不是好的idea。导致Java程序更容易OOm（超过-XX:MaxPermsize上限）
3. 到了JDK8，完全废弃了永久代的概念，改用与JRockit、J9一样在本地内存中实现的元空间（Metaspace）来代替
4. 元空间的本质和永久代类似，都是对JVM规范中方法区的实现。元空间与永久代最大的区别在于：**元空间不在虚拟机设置的内存中，而是使用本地内存**。
5. 永久代、元空间二者并不只是名字变了，内部结构也调整了
6. 根据《Java虚拟机规范》的规定，如果方法区无法满足新的内存分配需求时，将抛出OOM异常

<img src="https://npm.elemecdn.com/youthlql@1.0.8/JVM/chapter_006/0005.png">



## 6.3 设置方法区大小与 OOM

方法区的大小不必是固定的，JVM可以根据应用的需要动态调整。

### 6.3.1 JDK7及以前(永久代)

1. 通过-XX:Permsize来设置永久代初始分配空间。默认值是20.75M
2. -XX:MaxPermsize来设定永久代最大可分配空间。32位机器默认是64M，64位机器模式是82M
3. 当JVM加载的类信息容量超过了这个值，会报异常OutofMemoryError:PermGen space。



### 6.3.2 JDK8及以后(元空间)

> **JDK8 版本设置元空间大小**

1. 元数据区大小可以使用参数 **-XX:MetaspaceSize** 和 **-XX:MaxMetaspaceSize** 指定
2. 默认值依赖于平台，Windows下，-XX:MetaspaceSize 约为21M，-XX:MaxMetaspaceSize的值是-1，即没有限制。
3. 如果不指定大小，默认情况下，虚拟机会耗尽所有的可用系统内存。如果元数据区发生溢出，虚拟机一样会抛出异常OutOfMemoryError:Metaspace
4. -XX:MetaspaceSize：设置初始的元空间大小。对于一个 64位 的服务器端 JVM 来说，其默认的 -XX:MetaspaceSize值为21MB。这就是初始的高水位线，一旦触及这个水位线，Full GC将会被触发并卸载没用的类（即这些类对应的类加载器不再存活），然后这个高水位线将会重置。新的高水位线的值取决于GC后释放了多少元空间。如果释放的空间不足，那么在不超过MaxMetaspaceSize时，适当提高该值。如果释放空间过多，则适当降低该值。
5. 如果初始化的高水位线设置过低，上述高水位线调整情况会发生很多次。通过垃圾回收器的日志可以观察到Full GC多次调用。为了避免频繁地GC，建议将-XX:MetaspaceSize设置为一个相对较高的值。



### 6.3.3 如何解决方法区OOM

> 这个属于调优的问题，这里先简单的说一下

1. 要解决OOM异常或heap space的异常，一般的手段是首先通过内存映像分析工具（如Ec1ipse Memory Analyzer）对dump出来的堆转储快照进行分析，重点是确认内存中的对象是否是必要的，也就是要先分清楚到底是出现了内存泄漏（Memory Leak）还是内存溢出（Memory Overflow）
2. **内存泄漏**就是有大量的引用指向某些对象，但是这些对象以后不会使用了，但是因为它们还和GC ROOT有关联，所以导致以后这些对象也不会被回收，这就是内存泄漏的问题
3. 如果是内存泄漏，可进一步通过工具查看泄漏对象到GC Roots的引用链。于是就能找到泄漏对象是通过怎样的路径与GC Roots相关联并导致垃圾收集器无法自动回收它们的。掌握了泄漏对象的类型信息，以及GC Roots引用链的信息，就可以比较准确地定位出泄漏代码的位置。
4. 如果不存在内存泄漏，换句话说就是内存中的对象确实都还必须存活着，那就应当检查虚拟机的堆参数（-Xmx与-Xms），与机器物理内存对比看是否还可以调大，从代码上检查是否存在某些对象生命周期过长、持有状态时间过长的情况，尝试减少程序运行期的内存消耗。



## 6.4 方法区的内部结构

### 6.4.1 方法区存储什么？

#### 6.4.1.1 概念

方法区（Method Area）用于存储已被虚拟机加载的**类型信息、常量、静态变量、即时编译器编译后的代码缓存**等。

<img src="https://npm.elemecdn.com/youthlql@1.0.8/JVM/chapter_006/0007.png">

<img src="https://npm.elemecdn.com/youthlql@1.0.8/JVM/chapter_006/0008.png">



#### （1）**类型信息**

对每个加载的类型（类class、接口interface、枚举enum、注解annotation），JVM必须在方法区中存储以下类型信息：

1. 这个类型的完整有效名称（全名=包名.类名）
2. 这个类型直接父类的完整有效名（对于interface或是java.lang.Object，都没有父类）
3. 这个类型的修饰符（public，abstract，final的某个子集）
4. 这个类型直接接口的一个有序列表

#### **（2）域（Field）信息**

> 也就是我们常说的成员变量，域信息是比较官方的称呼

1. JVM必须在方法区中保存类型的所有域的相关信息以及域的声明顺序。
2. 域的相关信息包括：域名称，域类型，域修饰符（public，private，protected，static，final，volatile，transient的某个子集）

#### **（3）方法（Method）信息**

JVM必须保存所有方法的以下信息，同域信息一样包括声明顺序：

1. 方法名称
2. 方法的返回类型（包括 void 返回类型），void 在 Java 中对应的为 void.class
3. 方法参数的数量和类型（按顺序）
4. 方法的修饰符（public，private，protected，static，final，synchronized，native，abstract的一个子集）
5. 方法的字节码（bytecodes）、操作数栈、局部变量表及大小（abstract和native方法除外）
6. 异常表（abstract和native方法除外），异常表记录每个异常处理的开始位置、结束位置、代码处理在程序计数器中的偏移地址、被捕获的异常类的常量池索引



### 6.4.2 类变量说明

#### 6.4.2.1 non-final 类型的类变量

1. 静态变量和类关联在一起，随着类的加载而加载，他们成为类数据在逻辑上的一部分
2. 类变量被类的所有实例共享，即使没有类实例时，你也可以访问它



**举例**

1. 如下代码所示，即使我们把order设置为null，也不会出现空指针异常
2. 这更加表明了 static 类型的字段和方法随着类的加载而加载，并不属于特定的类实例

```java
public class MethodAreaTest {
    public static void main(String[] args) {
        Order order = null;
        order.hello();
        System.out.println(order.count);
    }
}

class Order {
    public static int count = 1;
    public static final int number = 2;

    public static void hello() {
        System.out.println("hello!");
    }
}
```

输出结果：

```
hello!
1
```



#### 6.4.2.2 全局常量：static final

1. 全局常量就是使用 static final 进行修饰
2. 被声明为final的类变量的处理方法则不同，**每个全局常量在编译的时候就会被分配了**。

查看上面代码，这部分的字节码指令

```java
class Order {
    public static int count = 1;
    public static final int number = 2;
    ...
}    
```

```java
public static int count;
    descriptor: I
    flags: ACC_PUBLIC, ACC_STATIC

  public static final int number;
    descriptor: I
    flags: ACC_PUBLIC, ACC_STATIC, ACC_FINAL
    ConstantValue: int 2
```

可以发现 staitc和final同时修饰的number 的值在编译上的时候已经写死在字节码文件中了。



### 6.4.3 运行时常量池

> **官方文档**：https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html

1. 方法区，内部包含了运行时常量池
2. 字节码文件，内部包含了常量池。

<img src="https://npm.elemecdn.com/youthlql@1.0.8/JVM/chapter_006/0009.png">



#### 6.4.3.1 常量池

1. 一个有效的字节码文件中除了包含类的版本信息、字段、方法以及接口等描述符信息外。还包含一项信息就是**常量池表**（**Constant Pool Table**），包括各种字面量和对类型、域和方法的符号引用。

<img src="https://npm.elemecdn.com/youthlql@1.0.8/JVM/chapter_006/0010.png">

**为什么需要常量池？**

1. 一个java源文件中的类、接口，编译后产生一个字节码文件。而Java中的字节码需要数据支持，通常这种数据会很大以至于不能直接存到字节码里，换另一种方式，可以存到常量池。这个字节码包含了指向常量池的引用。在动态链接的时候会用到运行时常量池，之前有介绍



**常量池中有啥？**

1. 数量值
2. 字符串值
3. 类引用
4. 字段引用
5. 方法引用



**常量池总结**

常量池、可以看做是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等类型。



#### 6.4.3.2 运行时常量池

1. 运行时常量池（Runtime Constant Pool）是方法区的一部分。
2. 常量池表（Constant Pool Table）是Class字节码文件的一部分，用于存放编译期生成的各种字面量与符号引用，**这部分内容将在类加载后存放到方法区的运行时常量池中**。（运行时常量池就是常量池在程序运行时的称呼）
3. 运行时常量池，在加载类和接口到虚拟机后，就会创建对应的运行时常量池。
4. JVM为每个已加载的类型（类或接口）都维护一个常量池。池中的数据项像数组项一样，是通过索引访问的。
5. 运行时常量池中包含多种不同的常量，包括编译期就已经明确的数值字面量，也包括到运行期解析后才能够获得的方法或者字段引用。**此时不再是常量池中的符号地址了，这里换为真实地址**。

- 运行时常量池，相对于Class文件常量池的另一重要特征是：具备动态性。

6. 运行时常量池类似于传统编程语言中的符号表（symbol table），但是它所包含的数据却比符号表要更加丰富一些。
7. 当创建类或接口的运行时常量池时，如果构造运行时常量池所需的内存空间超过了方法区所能提供的最大值，则JVM会抛OutofMemoryError异常。



## 6.5 方法区演进细节

### 6.5.1 永久代演进过程

1. 首先明确：只有Hotspot才有永久代
2. Hotspot中方法区的变化：

| JDK1.6及以前 | 有永久代（permanent generation），静态变量存储在永久代上     |
| ------------ | ------------------------------------------------------------ |
| JDK1.7       | 有永久代，但已经逐步 “去永久代”，**字符串常量池，静态变量移除，保存在堆中** |
| JDK1.8       | 无永久代，类型信息，字段，方法，常量保存在本地内存的元空间，但字符串常量池、静态变量仍然在堆中。 |

**JDK6**

方法区由永久代实现，使用 JVM 虚拟机内存（虚拟的内存）

<img src="https://npm.elemecdn.com/youthlql@1.0.8/JVM/chapter_006/0028.png">

**JDK7**

方法区由永久代实现，使用 JVM 虚拟机内存

<img src="https://npm.elemecdn.com/youthlql@1.0.8/JVM/chapter_006/0029.png">

**JDK8**

方法区由元空间实现，使用物理机本地内存

<img src="https://npm.elemecdn.com/youthlql@1.0.8/JVM/chapter_006/0030.png">





### 6.5.2 永久代为什么要被元空间替代？

> **官方文档**：http://openjdk.java.net/jeps/122

1. 元数据被移到了一个与堆不相连的本地内存区域，这个区域叫做元空间（Metaspace）。

2. 由于类的元数据分配在本地内存中，元空间的最大可分配空间就是系统可用内存空间。

3. 这项改动是很有必要的，原因有：

   1. **为永久代设置空间大小是很难确定的**。在某些场景下，如果动态加载类过多，容易产生Perm区的OOM。比如某个实际Web工程中，因为功能点比较多，在运行过程中，要不断动态加载很多类，经常出现致命错误。`Exception in thread 'dubbo client x.x connector' java.lang.OutOfMemoryError:PermGen space`而元空间和永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。 因此，默认情况下，元空间的大小仅受本地内存限制。

   2. **对永久代进行调优是很困难的**。方法区的垃圾收集主要回收两部分内容：常量池中废弃的常量和不再用的类型，**方法区的调优主要是为了降低Full GC**

      > 方法区的垃圾回收见6.5.4

      1. HotSpot的方法区是有垃圾回收的。《Java虚拟机规范》对方法区的约束非常宽松，提到过可以不要求虚拟机在方法区中实现垃圾收集。事实上也确实有未实现或未能完整实现方法区类型卸载的收集器存在（如JDK11时期的ZGC收集器就不支持类卸载）。
      2. 一般来说这个区域的回收效果比较难令人满意，尤其是类型的卸载，条件相当苛刻。但是这部分区域的回收有时又确实是必要的。以前Sun公司的Bug列表中，曾出现过的若干个严重的Bug就是由于低版本的HotSpot虚拟机对此区域未完全回收而导致内存泄漏。



### 6.5.3 字符串常量池（String Table）

> 更详细的String Table介绍见“7、字符串常量池 String Table”

#### 6.5.3.1 **字符串常量池 StringTable 为什么要调整位置？**

- 永久代的默认空间大小比较小
- 永久代垃圾回收频率低，大量的字符串无法及时回收，容易进行Full GC产生STW或者容易产生OOM：PermGen Space
- 堆中空间足够大，字符串可被及时回收



#### 6.5.3.2 对象实体在哪里放着？

- 静态变量引用的对象（如数组）始终分配在 堆内存。
- 静态变量本身的位置：
  - JDK6：静态变量存储在 方法区（PermGen）。
  - JDK7：静态变量移到了 堆内存（Heap）。
  - JDK8：静态变量仍存储在 堆内存，方法区被元空间取代。
- JVM 参数（如 PermSize 和 MetaspaceSize）与静态变量的关系仅体现在元数据存储上，与静态变量引用的对象无关。



#### 6.5.3.3 变量(名)存放在哪里？

#### （1）**JDK6环境下：**

1. **静态变量：**
   - 存储在方法区中，属于类的类型信息。
   - 但对象实例数据仍然存储在堆中（对象存放位置是堆，不受静态修饰符影响）。
2. **实例变量：**
   - 随着 `Test` 类的实例存储在堆中。
   - 每个实例都有自己的 `instanceObj`。
3. **局部变量：**
   - 存放在方法栈帧的局部变量表中。
   - 其数据对象仍然分配在堆中。
4. **所有对象数据**：变量的对象数据都在堆的 Eden 区中分配，即“**所有对象实例必然会分配在堆中**”。

> 简单来说就是指示牌可能在不同的地方存放，但是指示牌指向的东西都是放在堆里面的。

#### **（2）JDK7及以后（以HotSpot为例）：**

1. **静态变量的存储位置变化：**

   - 静态变量及其所属类的 `Class` 对象的元数据不再存储在方法区，而是存储在堆中（具体由虚拟机实现决定）。

     > 静态变量本质上是类的字段，是类本身的一部分，但它存储的是程序运行时需要的数据，而不是描述类本身的“元信息”。

2. **方法区的实现**：

   - 虽然《Java虚拟机规范》规定类信息应存储在方法区，但其具体实现（如静态变量是否放入方法区）由虚拟机厂商决定。
   - 在HotSpot中，方法区的部分功能由堆或元空间（Metaspace，JDK8后引入）实现。



### 6.5.4 方法区的垃圾回收

#### 6.5.4.1 认识

1. HotSpot的方法区是有垃圾回收的。《Java虚拟机规范》对方法区的约束非常宽松，提到过可以不要求虚拟机在方法区中实现垃圾收集。事实上也确实有未实现或未能完整实现方法区**类型卸载**的收集器存在（如JDK11时期的ZGC收集器就不支持类卸载）。
2. 一般来说这个区域的回收效果比较难令人满意，尤其是类型的卸载，条件相当苛刻。但是这部分区域的回收有时又确实是必要的。以前sun公司的Bug列表中，曾出现过的若干个严重的Bug就是由于低版本的HotSpot虚拟机对此区域未完全回收而导致内存泄漏。
3. 方法区的垃圾收集主要回收两部分内容：**常量池中废弃的常量**和**不再使用的类**。



#### 6.5.4.2 常量池垃圾回收

1. 方法区内常量池中主要存放的两大类常量：**字面量**和**符号引用**。

   - 字面量比较接近Java语言层次的常量概念，如文本字符串、被声明为final的常量值等。
   - 符号引用则属于编译原理方面的概念，包括下面三类常量：
     - 类和接口的全限定名
     - 字段的名称和描述符
     - 方法的名称和描述符

2. HotSpot虚拟机对常量池的回收策略是很明确的，只要常量池中的常量没有被任何地方引用，就可以被回收。

3. 回收废弃常量与回收Java堆中的对象非常类似。

   

#### 6.5.4.3 类的回收（类卸载）

1、判定一个类型是否属于“不再被使用的类”的条件比较苛刻。需要同时满足下面三个条件：

- 该类所有的实例都已经被回收，也就是Java堆中不存在该类及其任何派生子类的实例。
- 加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如OSGi、JSP的重加载等，否则通常是很难达成的。
- 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。

2、Java虚拟机被允许对满足上述三个条件的无用类进行回收，这里说的仅仅是“被允许”，而并不是和对象一样，没有引用了就必然会回收。关于是否要对类型进行回收，HotSpot虚拟机提供了`-Xnoclassgc`参数进行控制，还可以使用`-verbose:class` 以及 `-XX：+TraceClass-Loading`、`-XX：+TraceClassUnLoading`查看类加载和卸载信息

3、在大量使用反射、动态代理、CGLib等字节码框架，动态生成JSP以及OSGi这类频繁自定义类加载器的场景中，通常都需要Java虚拟机具备类型卸载的能力，以保证不会对方法区造成过大的内存压力。



## 6.6 直接内存

### 6.6.1 直接内存概述

1. 不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中定义的内存区域。
2. 直接内存是在Java堆外的、直接向系统申请的内存区间。
3. 来源于NIO，通过存在堆中的DirectByteBuffer操作Native内存
4. 通常，访问直接内存的速度会优于Java堆。即读写性能高。
5. 因此出于性能考虑，读写频繁的场合可能会考虑使用直接内存。
6. Java的NIO库允许Java程序使用直接内存，用于数据缓冲区



### 6.6.2 BIO 与 NIO

#### 6.6.2.1 **非直接缓存区（BIO）**

原来采用BIO的架构，在读写本地文件时，我们需要从用户态切换成内核态

<img src="https://npm.elemecdn.com/youthlql@1.0.8/JVM/chapter_006/0038.png" style="zoom:50%">

#### 6.6.2.2 **直接缓冲区（NIO）**

NIO 直接操作物理磁盘，省去了中间过程

<img src="https://npm.elemecdn.com/youthlql@1.0.8/JVM/chapter_006/0039.png" style="zoom:50%">

### 6.6.3 直接内存与 OOM

1. 直接内存也可能导致OutofMemoryError异常
2. 系统内存是有限的，Java堆和直接内存的总和依然受限于操作系统能给出的最大内存。
3. **直接内存的缺点为：**
   - 分配回收成本较高
   - 不受JVM内存回收管理
4. 直接内存大小可以通过MaxDirectMemorySize设置
5. 如果不指定，默认与堆的最大值-Xmx参数值一致

> 简单理解： Java Process Memory == Java Heap + Native Memory

<img src="https://npm.elemecdn.com/youthlql@1.0.8/JVM/chapter_006/0040.jpg">



## 6.7 常见面试题

1. 百度
   - 三面：说一下JVM内存模型吧，有哪些区？分别干什么的？
2. 蚂蚁金服：
   - Java8的内存分代改进
   - JVM内存分哪几个区，每个区的作用是什么？
   - 一面：JVM内存分布/内存结构？栈和堆的区别？堆的结构？为什么两个survivor区？
   - 二面：Eden和survior的比例分配
3. 小米：
   - jvm内存分区，为什么要有新生代和老年代
4. 字节跳动：
   - 二面：Java的内存分区
   - 二面：讲讲vm运行时数据库区
   - 什么时候对象会进入老年代？
5. 京东：
   - JVM的内存结构，Eden和Survivor比例。
   - JVM内存为什么要分成新生代，老年代，持久代。新生代中为什么要分为Eden和survivor。
6. 天猫：
   - 一面：Jvm内存模型以及分区，需要详细到每个区放什么。
   - 一面：JVM的内存模型，Java8做了什么改
7. 拼多多：
   - JVM内存分哪几个区，每个区的作用是什么？
8. 美团：
   - java内存分配
   - jvm的永久代中会发生垃圾回收吗？
   - 一面：jvm内存分区，为什么要有新生代和老年代？





# ===

## 7、字符串常量池（String Table）

> String Table在6.5.3种也有一些简单的减少，他是属于方法区的概念

## 7.1 认识String

### 7.1.1 认识

1. String被声明为final的，不可被继承
2. String实现了Serializable接口：表示字符串是支持序列化的。实现了Comparable接口：表示String可以比较大小
3. String在jdk8及以前内部定义了`final char value[]`用于存储字符串数据。JDK9时改为`byte[]`



### 7.1.2 String 的基本特性

- **String**：代表不可变的字符序列。简称：**不可变性**。
  1. 当对字符串重新赋值时，需要重写指定内存区域赋值，不能使用原有的value进行赋值。
  2. 当对现有的字符串进行连接操作时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。
  3. 当调用String的replace()方法修改指定字符或字符串时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。

- 通过字面量的方式（区别于new）给一个字符串赋值，此时的字符串值声明在字符串常量池中。



### 7.1.3  JDK9对String结构的修改

> **官方文档**：http://openjdk.java.net/jeps/254

**为什么改为 byte\[\] 存储？**

1. **String不用char\[\] 来存储，改成了byte \[\] 加上编码标记，主要是为了节约一些空间**
2. String类的当前实现将字符存储在char数组中，每个字符使用两个字节(16位)。
3. 从许多不同的应用程序收集的数据表明，字符串是堆使用的主要组成部分，而且大多数字符串对象只包含拉丁字符（Latin-1）。这些字符只需要一个字节的存储空间，因此这些字符串对象的内部char数组中有一半的空间将不会使用，产生了大量浪费。
4. 之前 String 类使用 UTF-16 的 char\[\] 数组存储，现在改为 byte\[\] 数组 外加一个编码标识存储。该编码表示如果你的字符是ISO-8859-1或者Latin-1，那么只需要一个字节存。如果你是其它字符集，比如UTF-16，你仍然用两个字节存
5. 同时基于String的数据结构，例如StringBuffer和StringBuilder也同样做了修改

```java
// 之前
private final char value[];
// 之后
private final byte[] value
```



### 7.1.4 String 的底层结构

**字符串常量池是不会存储相同内容的字符串的**

1. String的String Pool（字符串常量池）是一个固定大小的Hashtable，默认值大小长度是1009。如果放进String Pool的String非常多，就会造成Hash冲突严重，从而导致链表会很长，而链表长了后直接会造成的影响就是当调用String.intern()方法时性能会大幅下降。
2. 在JDK6中StringTable是固定的，就是1009的长度，所以如果常量池中的字符串过多就会导致效率下降很快
3. 在JDK7中，StringTable的长度默认值是60013
4. 在JDK8中，StringTable的长度默认值是60013，StringTable可以设置的最小值为1009



**测试不同 StringTable 长度下，程序的性能**

```java
/**
 * 产生10万个长度不超过10的字符串，包含a-z,A-Z
 */
public class GenerateString {
    public static void main(String[] args) throws IOException {
        FileWriter fw =  new FileWriter("words.txt");

        for (int i = 0; i < 100000; i++) {
            //1 - 10
           int length = (int)(Math.random() * (10 - 1 + 1) + 1);
            fw.write(getString(length) + "\n");
        }

        fw.close();
    }

    public static String getString(int length){
        String str = "";
        for (int i = 0; i < length; i++) {
            //65 - 90, 97-122
            int num = (int)(Math.random() * (90 - 65 + 1) + 65) + (int)(Math.random() * 2) * 32;
            str += (char)num;
        }
        return str;
    }
}

```

```java
public class StringTest2 {
    public static void main(String[] args) {

        BufferedReader br = null;
        try {
            br = new BufferedReader(new FileReader("words.txt"));
            long start = System.currentTimeMillis();
            String data;
            while((data = br.readLine()) != null){
                data.intern(); //如果字符串常量池中没有对应data的字符串的话，则在常量池中生成
            }

            long end = System.currentTimeMillis();

            System.out.println("花费的时间为：" + (end - start));//1009:143ms  100009:47ms
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            if(br != null){
                try {
                    br.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }

            }
        }
    }
}

```

- -XX:StringTableSize=1009 ：程序耗时 143ms
- -XX:StringTableSize=100009 ：程序耗时 47ms



### 7.1.5 String 的内存分配

1. Java 6及以前，字符串常量池存放在永久代
2. Java 7中 Oracle的工程师对字符串池的逻辑做了很大的改变，即将字符串常量池的位置调整到Java堆内
   - 所有的字符串都保存在堆（Heap）中，和其他普通对象一样，这样可以让你在进行调优应用时仅需要调整堆大小就可以了。
   - 字符串常量池概念原本使用得比较多，但是这个改动使得我们有足够的理由让我们重新考虑在Java 7中使用String.intern()。
3. Java8元空间，字符串常量在堆

<img src="https://npm.elemecdn.com/youthlql@1.0.8/JVM/chapter_009/0003.png">

<img src="https://npm.elemecdn.com/youthlql@1.0.8/JVM/chapter_009/0004.png">



## 7.3 String Table位置调整的原因

> 官方文档**:https://www.oracle.com/java/technologies/javase/jdk7-relnotes.html#jdk7changes

1. 为什么要调整位置？
   - 永久代的默认空间大小比较小
   - 永久代垃圾回收频率低，大量的字符串无法及时回收，容易进行Full GC产生STW或者容易产生OOM：PermGen Space
   - 堆中空间足够大，字符串可被及时回收
2. 在JDK 7中，interned字符串不再在Java堆的永久代中分配，而是在Java堆的主要部分（称为年轻代和年老代）中分配，与应用程序创建的其他对象一起分配。
3. 此更改将导致驻留在主Java堆中的数据更多，驻留在永久生成中的数据更少，因此可能需要调整堆大小。



## 7.4 JVM对String对象的分配操作

**Java语言规范里要求完全相同的字符串字面量，应该包含同样的Unicode字符序列（包含同一份码点序列的常量），并且必须是指向同一个String类实例。**

举例

```java
public class StringTest4 {
    public static void main(String[] args) {
        System.out.println();//2293
        System.out.println("1");//2294
        System.out.println("2");
        System.out.println("3");
        System.out.println("4");
        System.out.println("5");
        System.out.println("6");
        System.out.println("7");
        System.out.println("8");
        System.out.println("9");
        System.out.println("10");//2303
        //如下的字符串"1" 到 "10"不会再次加载
        System.out.println("1");//2304
        System.out.println("2");//2304
        System.out.println("3");
        System.out.println("4");
        System.out.println("5");
        System.out.println("6");
        System.out.println("7");
        System.out.println("8");
        System.out.println("9");
        System.out.println("10");//2304
    }
}
```



## 7.5 字符串拼接操作

### 7.5.1 各种方式创建的字符串保存位置

#### （1）使用" "创建的字符串结果在常量池

#### （2）常量与常量的拼接结果在常量池

> 常量与常量的拼接结果在常量池，原理是编译期优化
>
> ```java
> String s1 = "hello";
> String s2 = "world";
> String s3 = "hello" + "world";  // 常量拼接
> ```
>
> **编译时优化**：编译器会直接把 `"hello" + "world"` 优化为 `"helloworld"`，所以 `s3` 的值在编译时就固定为 `"helloworld"`。
>
> 拼接结果直接存放在**常量池**中。

#### （3）常量池中不会存在相同内容的变量

#### （4）拼接前后，只要其中有一个是变量，结果就在堆中变量

> 拼接前后，只要其中有一个是变量，结果就在堆中变量拼接的原理是StringBuilder
>
> ```java
> String s1 = "hello";
> String s2 = "world";
> String s3 = s1 + s2;  // s3 是拼接后的新字符串
> // 如果s1和s2都是final就在常量池，原因是编译期优化
> ```
>
> 原理：Java 使用 StringBuilder 来动态拼接字符串：
>
> - `StringBuilder` 是一个用于高效处理字符串拼接的类。
> - 它在内存中开辟新的空间存储拼接后的内容。
>
> 拼接结果存储在**堆内存**中，而不是字符串常量池中。

#### （5）intern()方法对字符串进行拼接

如果拼接的结果调用intern()方法，根据该字符串是否在常量池中存在，分为：

- 如果存在，则返回字符串在常量池中的地址

- 如果字符串常量池中不存在该字符串，则在常量池中创建一份，并返回此对象的地址

  > 已经在堆中分配内存的String对象调用intern方法的补充：
  >
  > - jdk1.6中
  >     （1）如果串池中有，返回已有的串池中的对象的地址
  >
  >     （2）如果没有，把此对象放入串池，并返回串池中的对象地址
  >
  > - Jdk1.7起
  >
  >     （1）如果串池中有，返回已有的串池中的对象的地址
  >
  >     （2）如果没有，则会把对象的引用地址复制一份，放入串池,并返回串池中的引用地址。也就是说会在串池里面新建一个对象，但是这个对象不存具体内容，而是一个地址，这个地址就指向堆中的真实数据，所以会出现下面测试代码中都指向同一个地址的情况，测试代码测试了java8、11、17，都是一样的，改动是从java7开始的，因为jvm将常量池从永久代放到了堆里面，可能是出于节省空间的目的。
  >
  > 
  >
  > 测试代码一：
  >
  > ```java
  > String s1 = new String("hello") + new String("world"); // 堆中的新对象
  > // "hello"、"world" 创建到常量池
  > // new String 在堆中再创建hello、world 的对象
  > // 堆中hello、world对象相加，得到 hello world 的堆对象
  > String s2 = s1.intern();  // 常量池没有helloworld对象，创建常量池对象指向堆对象
  > String s3 = "helloworld"; // 常量池中存的是指向堆对象的地址，直接按地址找过去
  > 
  > // 比较 s1 和 s3
  > System.out.println(s1 == s3); 
  > 
  > // 比较 s2 和 s3
  > System.out.println(s2 == s3);
  > 
  > 
  > System.out.println("s1: " + System.identityHashCode(s1));
  > System.out.println("s2: " + System.identityHashCode(s2));
  > System.out.println("s3: " + System.identityHashCode(s3));
  > ```
  >
  > 输出
  >
  > ```
  > true
  > true
  > s1: 990368553
  > s2: 990368553
  > s3: 990368553
  > ```
  >
  > 测试版本：Java8、11、17
  >
  > <img src="http://jason243.online/JVM/jvm001.png" />
  >
  > 测试代码二：
  >
  > ```java
  > String s1 = new String("hello") + new String("world"); // 堆中的新对象
  > //换个位置
  > String s3 = "helloworld"; // 常量池中没有，新建常量池中的对象
  > String s2 = s1.intern();  // 复用常量池中的对象
  > 
  > // 比较 s1 和 s3
  > System.out.println(s1 == s3); // 一个在堆，一个在常量池
  > 
  > // 比较 s2 和 s3
  > System.out.println(s2 == s3);
  > 
  > 
  > System.out.println("s1: " + System.identityHashCode(s1)); // s1 是堆中的对象
  > System.out.println("s2: " + System.identityHashCode(s2)); // s2 指向常量池
  > System.out.println("s3: " + System.identityHashCode(s3)); // s3 指向常量池
  > ```
  >
  > ```
  > false
  > true
  > s1: 990368553
  > s2: 1480010240
  > s3: 1480010240
  > ```
  >
  > 测试代码三：
  >
  > ```java
  > String s1 = new String("hello") + new String("world"); // 堆中对象
  > String s4 = s1; // 复用堆中对象
  > String s2 = s1.intern(); // 常量池没有helloworld对象，创建常量池对象指向堆对象
  > String s5 = s1; // 复用堆中对象
  > String s3 = "helloworld"; // 常量池中存的是指向堆对象的地址，直接按地址找过去
  > 
  > 
  > System.out.println("s1: " + System.identityHashCode(s1));
  > System.out.println("s2: " + System.identityHashCode(s2));
  > System.out.println("s3: " + System.identityHashCode(s3));
  > System.out.println("s4: " + System.identityHashCode(s4));
  > System.out.println("s5: " + System.identityHashCode(s5));
  > 
  > ```
  >
  > ```
  > s1: 990368553
  > s2: 990368553
  > s3: 990368553
  > s4: 990368553
  > s5: 990368553
  > ```



### 7.5.2 字符串拼接的底层细节

#### 7.5.2.1 字符串变量拼接底层是SB()

```java
    @Test
    public void test3(){
        String s1 = "a";
        String s2 = "b";
        String s3 = "ab";
        /*
        ① StringBuilder s = new StringBuilder();
        ② s.append("a")
        ③ s.append("b")
        ④ s.toString()  --> 约等于 new String("ab")，但不等价

        补充：在jdk5.0之后使用的是StringBuilder,在jdk5.0之前使用的是StringBuffer
         */
        String s4 = s1 + s2;//
        System.out.println(s3 == s4);//false
    }
```



#### 7.5.2.2 字符串常量以变量的形式拼接仍然按照常量进行编译期优化

```java
/*
    1. 字符串拼接操作不一定使用的是StringBuilder!
       如果拼接符号左右两边都是字符串常量或常量引用，则仍然使用编译期优化，即非StringBuilder的方式。
    2. 针对于final修饰类、方法、基本数据类型、引用数据类型的量的结构时，能使用上final的时候建议使用上。
     */
    @Test
    public void test4(){
        final String s1 = "a";
        final String s2 = "b";
        String s3 = "ab";
        String s4 = s1 + s2;
        System.out.println(s3 == s4);//true
    }
```

> 使用StringBuilder的append进行拼接效率一般大于直接字符串拼接，因为字符串底层调用的也是sb，但是用字符串每次拼接他都会new一个sb对象。



## 7.6 intern() 的使用

### 7.6.1 intern() 方法的说明

```java
public native String intern();
```

1. intern是一个native方法，调用的是底层C的方法

2. 字符串常量池池最初是空的，由String类私有地维护。在调用intern方法时，如果池中已经包含了由equals(object)方法确定的与该字符串内容相等的字符串，则返回池中的字符串地址。否则，该字符串对象将被添加到池中，并返回对该字符串对象的地址。（这是源码里的大概翻译）

3. 如果不是用双引号声明的String对象，可以使用String提供的intern方法：intern方法会从字符串常量池中查询当前字符串是否存在，若不存在就会将当前字符串放入常量池中。比如：

   ```
   String myInfo = new string("I love atguigu").intern();
   ```

4. 通俗点讲，Interned String就是尽可能确保字符串在内存里只有一份拷贝，这样可以节约内存空间，加快字符串操作任务的执行速度。注意，这里说的是内存中，因为涉及到JDK7开始intern对已经在堆中分配内存的String对象调用intern方法时的操作结果改变。

   > 尽可能，因为也有例外。
   >
   > 比如JDK7之前，已经在堆中分配内存的String对象调用intern方法时会在StringTable中直接创建一个新的，此时有两份。



### 7.6.2 new String() 的说明

#### 7.6.2.1 new String(“ab”)会创建几个对象？

两个，一个是括号里的"ab"，在String Table中；一个是new出来的"ab"对象，在堆中

>  * new String("ab")会创建几个对象？看字节码，就知道是两个。
>  *     一个对象是：new关键字在堆空间创建的
>  *     另一个对象是：字符串常量池中的对象"ab"。 字节码指令：ldc



#### 7.6.2.2 new String(“a”) + new String(“b”) 会创建几个对象？

六个：

- 对象1：new StringBuilder()

- 对象2： new String("a")

- 对象3： 常量池中的"a"

- 对象4： new String("b")

- 对象5： 常量池中的"b"

- 对象6 ：new String("ab").toString()

  强调一下，toString()的调用，在字符串常量池中，没有生成"ab"，所以只有六个对象

  > 额外补充
  >
  > 堆中的字符串对象是不会去重的，也就是说，可以通过这种方法在堆里面创建一堆的"ab"，这样会浪费大量的内存，这正是intern()要解决的问题



### 7.6.3 有点难的面试题

> 在7.5.1(5)里面已经测试过了
>
> intern规则：
>
> - jdk1.6中
>   （1）如果串池中有，返回已有的串池中的对象的地址
>
>   （2）如果没有，把此对象放入串池，并返回串池中的对象地址
>
> - Jdk1.7起
>
>   （1）如果串池中有，返回已有的串池中的对象的地址
>
>   （2）如果没有，则会把对象的引用地址复制一份，放入串池,并返回串池中的引用地址。也就是说会在串池里面新建一个对象，但是这个对象不存具体内容，而是一个地址，这个地址就指向堆中的真实数据，所以会出现下面测试代码中都指向同一个地址的情况，测试代码测试了java8、11、17，都是一样的，改动是从java7开始的，因为jvm将常量池从永久代放到了堆里面，可能是出于节省空间的目的。

```java
public class StringIntern {
    public static void main(String[] args) {

        //测试1
        String s = new String("1"); // String Table和堆里面各一个“1”
        s.intern();//调用此方法之前，字符串常量池中已经存在了"1"
        String s2 = "1"; // 指向String Table里的“1”
        System.out.println(s == s2);//jdk6：false   jdk7/8：false
        
        
        //测试2
        String s3 = new String("1") + new String("1");
        //String Table和堆里面各一个“1”，堆里面一个“11”
	    s3.intern(); // String Table创建“11”的对象，这里不同jdk版本有差别，具体看上面的解释
        String s4 = "11";// 指向String Table里的“11”
        System.out.println(s3 == s4);//jdk6：false  jdk7/8：true
    }
}

```



面试题的拓展

```java
public class StringIntern1 {
    public static void main(String[] args) {
        
        String s3 = new String("1") + new String("1");//s3指向堆中
        String s4 = "11";  //String Table没有，新建一个“11”对象，s4指过去
        String s5 = s3.intern(); //String Table已经有了，s5指向String Table里的

        System.out.println(s3 == s4);//false
        System.out.println(s5 == s4);//true
    }
}
```





### 7.6.4 intern() 的空间效率

**分析**

1、直接 new String ：由于每个 String 对象都是 new 出来的，所以程序需要维护大量存放在堆空间中的 String 实例，程序内存占用也会变高

2、使用 intern() 方法：由于数组中字符串的引用都指向字符串常量池中的字符串，所以程序需要维护的 String 对象更少，内存占用也更低



**结论**：

1. 对于程序中大量使用存在的字符串时，尤其存在很多已经重复的字符串时，使用intern()方法能够节省很大的内存空间。
2. 大的网站平台，需要内存中存储大量的字符串。比如社交网站，很多人都存储：北京市、海淀区等信息。这时候如果字符串都调用intern() 方法，就会很明显降低内存的大小。



## 7.7 StringTable 的垃圾回收

**StringTable中会发生垃圾回收**

```java
/**
 * String的垃圾回收:
 * -Xms15m -Xmx15m -XX:+PrintStringTableStatistics -XX:+PrintGCDetails
 */
public class StringGCTest {
    public static void main(String[] args) {
        for (int j = 0; j < 100000; j++) {
            String.valueOf(j).intern();
        }
    }
}
```



输出结果：

- 在 PSYoungGen 区发生了垃圾回收
- Number of entries 和 Number of literals 明显没有 100000
- 以上两点均说明 StringTable 区发生了垃圾回收

<img src="https://npm.elemecdn.com/youthlql@1.0.8/JVM/chapter_009/0022.jpg">



<img src="https://npm.elemecdn.com/youthlql@1.0.8/JVM/chapter_009/0023.jpg"/>



## 7.8 G1 中的 String 去重操作

> **官方文档**：http://openjdk.java.net/jeps/192



### 7.8.1 **String去重操作的背景**

> 注意不是字符串常量池的去重操作，字符串常量池本身就没有重复的

1. 背景：对许多Java应用（有大的也有小的）做的测试得出以下结果：
   - 堆存活数据集合里面String对象占了25%
   - 堆存活数据集合里面重复的String对象有13.5%
   - String对象的平均长度是45
2. 许多大规模的Java应用的瓶颈在于内存，测试表明，在这些类型的应用里面，Java堆中存活的数据集合差不多25%是String对象。更进一步，这里面差不多一半String对象是重复的，重复的意思是说：`str1.equals(str2)= true`。堆上存在重复的String对象必然是一种内存的浪费。这个项目将在G1垃圾收集器中实现自动持续对重复的String对象进行去重，这样就能避免浪费内存。



### 7.8.2 **String 去重的实现**

1. **垃圾回收器扫描堆对象**：
   - 在垃圾回收过程中，检查堆上的存活对象，找出可能需要去重的 `String` 对象。
2. **将候选对象加入队列**：
   - 将符合条件的 `String` 对象引用加入一个队列，等待后台线程处理。
3. **后台线程去重**：
   - 后台线程逐个处理队列中的 `String` 对象。
4. **查找已有的共享数组**：
   - 使用一个 `Hashtable` 记录已存在的唯一 `char[]` 数组。
   - 如果 `Hashtable` 中已存在相同的 `char[]`，`String` 对象的引用调整为共享该数组，释放原来的数组引用。
5. **新增未共享的数组**：
   - 如果 `Hashtable` 中没有找到相同的 `char[]`，将当前数组加入 `Hashtable`，以便后续共享。



### 7.8.3 **核心机制**

- **目标**：通过共享相同内容的 `char[]` 数组减少内存占用。
- **关键点**：利用 `Hashtable` 来实现去重，通过后台线程自动优化内存。



### 7.8.4 **命令行选项**

1. UseStringDeduplication(bool) ：开启String去重，默认是不开启的，需要手动开启。
2. PrintStringDeduplicationStatistics(bool) ：打印详细的去重统计信息
3. stringDeduplicationAgeThreshold(uintx) ：达到这个年龄的String对象被认为是去重的候选对象







# ===

# 8、对象的实例化内存布局与访问定位

## 8.1 对象的实例化

<img src="https://npm.elemecdn.com/youthlql@1.0.8/JVM/chapter_007/0001.png">

### 8.1.1 对象创建的方式

1. new：最常见的方式、单例类中调用getInstance的静态类方法，XXXFactory的静态方法
2. Class的newInstance方法：在JDK9里面被标记为过时的方法，因为只能调用空参构造器，并且权限必须为 public
3. Constructor的newInstance(Xxxx)：反射的方式，可以调用空参的，或者带参的构造器
4. 使用clone()：不调用任何的构造器，要求当前的类需要实现Cloneable接口中的clone方法
5. 使用序列化：从文件中，从网络中获取一个对象的二进制流，序列化一般用于Socket的网络传输
6. 第三方库 Objenesis



### 8.1.2 对象创建的步骤

> **从字节码看待对象的创建过程**

**1、判断对象对应的类是否加载、链接、初始化**

1. 虚拟机遇到一条new指令，首先去检查这个指令的参数能否在Metaspace的常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载，解析和初始化。（即判断类元信息是否存在）。
2. 如果该类没有加载，那么在双亲委派模式下，使用当前类加载器以ClassLoader + 包名 + 类名为key进行查找对应的.class文件，如果没有找到文件，则抛出ClassNotFoundException异常，如果找到，则进行类加载，并生成对应的Class对象。



**2、为对象分配内存**

1. 首先计算对象占用空间的大小，接着在堆中划分一块内存给新对象。如果实例成员变量是引用变量，仅分配引用变量空间即可，即4个字节大小
2. 如果内存规整：采用指针碰撞分配内存
   - 如果内存是规整的，那么虚拟机将采用的是指针碰撞法（Bump The Point）来为对象分配内存。
   - 意思是所有用过的内存在一边，空闲的内存放另外一边，中间放着一个指针作为分界点的指示器，分配内存就仅仅是把指针往空闲内存那边挪动一段与对象大小相等的距离罢了。
   - 如果垃圾收集器选择的是Serial ，ParNew这种基于压缩算法的，虚拟机采用这种分配方式。一般使用带Compact（整理）过程的收集器时，使用指针碰撞。
   - 标记压缩（整理）算法会整理内存碎片，堆内存一存对象，另一边为空闲区域
3. 如果内存不规整
   - 如果内存不是规整的，已使用的内存和未使用的内存相互交错，那么虚拟机将采用的是空闲列表来为对象分配内存。
   - 意思是虚拟机维护了一个列表，记录上哪些内存块是可用的，再分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的内容。这种分配方式成为了 “空闲列表（Free List）”
   - 选择哪种分配方式由Java堆是否规整所决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定
   - 标记清除算法清理过后的堆内存，就会存在很多内存碎片。



**3、处理并发问题**

1. 采用CAS+失败重试保证更新的原子性
2. **每个线程预先分配TLAB - 通过设置 -XX:+UseTLAB参数来设置（区域加锁机制）**
3. **在Eden区给每个线程分配一块区域**



**4、初始化分配到的空间**

- 所有属性设置默认值，保证对象实例字段在不赋值可以直接使用
- 给对象属性赋值的顺序：

1. 属性的默认值初始化

   > 也就是赋默认值0、null等

2. 显示初始化/代码块初始化（并列关系，谁先谁后看代码编写的顺序）

   > 就是根据类里面的赋值语句进行赋值。事实上跟步骤1并不是紧密相连的状态，他们一个发生在类加载器加载阶段，一个发生在new创建新对象阶段

3. 构造器初始化

   > 这是构造类的前置准备，也就是真正执行类构造器逻辑之前的准备步骤。
   >
   > 他主要做两件事，一个是确定调用哪一个类构造器，另一个是根据类构造器里面的内容分配内存，设置默认值。



**5、设置对象的对象头**

将对象的所属类（即类的元数据信息）、对象的HashCode和对象的GC信息、锁信息等数据存储在对象的对象头中。这个过程的具体设置方式取决于JVM实现。



**6、执行init方法进行初始化**

1. 在Java程序的视角看来，初始化才正式开始。初始化成员变量，执行实例化代码块，调用类的构造方法，并把堆内对象的首地址赋值给引用变量
2. 因此一般来说（由字节码中跟随invokespecial指令所决定），new指令之后会接着就是执行init方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完成创建出来。



> 代码案例

```java
class Parent {
    int a = 10; // 显式初始化
    Parent() {
        System.out.println("Parent 构造器");
        a = 20; // 构造器初始化
    }
}

class Child extends Parent {
    int b = 30; // 显式初始化
    { b = 40; } // 代码块初始化
    Child() {
        System.out.println("Child 构造器");
        b = 50; // 构造器初始化
    }
}

public class Test {
    public static void main(String[] args) {
        Child obj = new Child();
        System.out.println("a = " + obj.a + ", b = " + obj.b);
    }
}
```



## 8.2 对象的内存布局

<img src="https://npm.elemecdn.com/youthlql@1.0.8/JVM/chapter_007/0002.png">



> **内存布局总结**

```java
public class Customer{
    int id = 1001;
    String name;
    Account acct;

    {
        name = "匿名客户";
    }
    public Customer(){
        acct = new Account();
    }
	public static void main(String[] args) {
        Customer cust = new Customer();
    }
}
class Account{

}
```



图解内存布局

<img src="https://npm.elemecdn.com/youthlql@1.0.8/JVM/chapter_007/0003.png">



## 8.3 对象的访问定位

<img src="https://npm.elemecdn.com/youthlql@1.0.8/JVM/chapter_007/0004.png">

**对象的两种访问方式：句柄访问和直接指针**

**1、句柄访问**

1. 缺点：在堆空间中开辟了一块空间作为句柄池，句柄池本身也会占用空间；通过两次指针访问才能访问到堆中的对象，效率低
2. 优点：reference中存储稳定句柄地址，对象被移动（垃圾收集时移动对象很普遍）时只会改变句柄中实例数据指针即可，reference本身不需要被修改

<img src="https://npm.elemecdn.com/youthlql@1.0.8/JVM/chapter_007/0005.png" style="zoom:60%">



**2、直接指针（HotSpot采用）**

1. 优点：直接指针是局部变量表中的引用，直接指向堆中的实例，在对象实例中有类型指针，指向的是方法区中的对象类型数据
2. 缺点：对象被移动（垃圾收集时移动对象很普遍）时需要修改 reference 的值

<img src="https://npm.elemecdn.com/youthlql@1.0.8/JVM/chapter_007/0006.png" style="zoom:60%">



# ======